### General ###

define endian=big;
define alignment=2;
define space ram type=ram_space size=4 wordsize=1 default;
define space register type=register_space size=4;

define register offset=0 size=4
[r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15 r16 r17 r18 r19 r20 r21 r22 r23 r24 r25 p0 p1 fp gp lp sp];

define register offset=0x90 size=4
[pc ipc mult_addr mult_inc];

define register offset=0x100 size=8
[d0 d1];

define register offset=0x100 size=4
[d0.hi d0.lo d1.hi d1.lo itb];

define register offset=0x200 size=4
[dma_cfg dma_gcsw dma_chnsel dma_act dma_setup dma_isaddr dma_esaddr dma_tcnt dma_status dma_2dset dma_2dsctl];

define register offset=0x300 size=4
[pfmc0 pfmc1 pfmc2 pfm_ctl];

define register offset=0x400 size=4
[cpu_ver core_id icm_cfg dcm_cfg mmu_cfg msc_cfg psw ipsw p_ipsw ivb int_ctrl eva p_eva itype p_itype merr p_ipc oipc p_p0 p_p1 int_mask int_mask2 int_pend int_pend2 int_trigger sp_usr sp_priv int_pri int_pri2 mmu_ctl l1_pptb tlb_vpn tlb_data tlb_misc vlpt_idx ilmb dlmb cache_ctl hsmp_saddr hsmp_eaddr sdz_ctl misc_ctl fucpr bpc0 bpc1 bpc2 bpc3 bpc4 bpc5 bpc6 bpc7 bpa0 bpa1 bpa2 bpa3 bpa4 bpa5 bpa6 bpa7 bpam0 bpam1 bpam2 bpam3 bpam4 bpam5 bpam6 bpam7 bpv0 bpv1 bpv2 bpv3 bpv4 bpv5 bpv6 bpv7 bpcid0 bpcid1 bpcid2 bpcid3 bpcid4 bpcid5 bpcid6 bpcid7 edm_cfg edmsw edm_ctl edm_dtr bpmtc dimbr tecr0 tecr1 prusr_acc_ctl];

define token instr32(32)
    OpSz        = (31, 31)
    Opc         = (25, 30)
    Rt          = (20, 24)
    Rth         = (21, 24)
    Rtl         = (21, 24)
    Ra          = (15, 19)
    Rb          = (10, 14)
    Rd          = (5, 9)
    Rs          = (5, 9)
    Sub5        = (0, 4)
    Sub6        = (0, 5)
    Sub7        = (0, 6)
    Sub8        = (0, 7)
    Imm5u       = (10, 14)
    Imm5s       = (10, 14) signed
    Br1t        = (14, 14)
    Br2t        = (16, 19)
    Alu2Mod     = (6, 9)
    Dtl         = (22, 24)
    Dt          = (21, 21)
    Dtlow       = (21, 21)
    Dthigh      = (21, 21)
    Dtr         = (20, 20)
    JIt         = (24, 24)
    Imm19s      = (0, 18) signed
    Imm18s      = (0, 17) signed
    Imm17s      = (0, 16) signed
    Imm16s      = (0, 15) signed
    Imm14s      = (0, 13) signed
    Imm15u      = (0, 14)
    Imm15s      = (0, 14) signed
    Imm20u      = (0, 19)
    Imm20s      = (0, 19) signed
    Imm24s      = (0, 23) signed
    Imm11s		= (8, 18) signed
    Imm8s		= (0, 7) signed
    Imm8_7      = (7, 14)

    sv          = (8, 9)
    SrIdx       = (10, 19)
    Swid        = (5, 19)

    CctlZ       = (11, 14)
    CctlLevel   = (10, 10)
    CctlSub     = (5, 9)
    CctlSub20   = (5, 7)
    CctlSub43   = (8, 9)

    MsyncZ      = (8, 19)
    MsyncSub    = (5, 7)

    DtIt        = (8, 9)
    Jz          = (6, 7)
    JrHint      = (5, 5)

    ToggleL     = (21, 24)
    Toggle      = (20, 20)

    Usr         = (15, 19)
    Group       = (10, 14)

    DprefD      = (24, 24)
    DprefSub    = (20, 23)

    TlbopSub    = (5, 9)

    StandbyZ    = (7, 9)
    StandbySub  = (5, 6)

    GpSub1      = (19, 19)
    GpSub2      = (18, 19)
    GpSub3      = (17, 19)

    sh          = (5, 9)

    Bxxc		= (19, 19)

    LsmwRa = (15, 19)
    LsmwRb = (20, 24)
    LsmwRb_ = (20, 24)
    LsmwRe = (10, 14)
    LsmwRe_ = (10, 14)
    Enable4 = (6, 9)
    Enable4_fp = (9, 9)
    Enable4_gp = (8, 8)
    Enable4_lp = (7, 7)
    Enable4_sp = (6, 6)
    LsmwLs = (5, 5)
    LsmwBa = (4, 4)
    LsmwId = (3, 3)
    LsmwM = (2, 2)
    LsmwSub = (0, 1)
;

attach variables [Rt Rs Ra Rb Rd LsmwRa LsmwRb LsmwRe] [
    r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15 r16 r17 r18 r19 r20 r21 r22 r23 r24 r25 p0 p1 fp gp lp sp
];

attach variables [Rtl] [
    r0 r2 r4 r6 r8 r10 r12 r14 r16 r18 r20 r22 r24 p0 fp lp
];

attach variables [Rth] [
    r1 r3 r5 r7 r9 r11 r13 r15 r17 r19 r21 r23 r25 p1 gp sp
];

attach variables [Dt] [
    d0 d1
];

attach variables [Dtlow] [
    d0.lo d1.lo
];

attach variables [Dthigh] [
    d0.hi d1.hi
];

# attach variables [SrIdx] [
#     msc_cfg
# ];

### ALU Instruction with Immediate ###

:addi  Rt, Ra, Imm15s is OpSz=0 & Opc=0b101000 & Rt & Ra & Imm15s { Rt = Ra + Imm15s; }
:subri Rt, Ra, Imm15s is OpSz=0 & Opc=0b101001 & Rt & Ra & Imm15s { Rt = Imm15s - Ra; }
:andi  Rt, Ra, Imm15u is OpSz=0 & Opc=0b101010 & Rt & Ra & Imm15u { Rt = Ra & Imm15u; }
:ori   Rt, Ra, Imm15u is OpSz=0 & Opc=0b101100 & Rt & Ra & Imm15u { Rt = Ra | Imm15u; }
:xori  Rt, Ra, Imm15u is OpSz=0 & Opc=0b101011 & Rt & Ra & Imm15u { Rt = Ra ^ Imm15u; }
:slti  Rt, Ra, Imm15s is OpSz=0 & Opc=0b101110 & Rt & Ra & Imm15s { Rt = zext(Ra < Imm15s); }
:sltsi Rt, Ra, Imm15s is OpSz=0 & Opc=0b101111 & Rt & Ra & Imm15s { Rt = zext(Ra s< Imm15s); }
:movi  Rt,     Imm20s is OpSz=0 & Opc=0b100010 & Rt & Imm20s      { Rt = Imm20s; }
:sethi Rt,     Imm20u is OpSz=0 & Opc=0b100011 & Rt & Imm20u      { Rt = Imm20u << 12;}


### ALU Instruction ###

:add  Rt, Ra, Rb is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rd=0 & Sub5=0b00000 { Rt = Ra + Rb; }
:sub  Rt, Ra, Rb is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rd=0 & Sub5=0b00001 { Rt = Ra - Rb; }
:and  Rt, Ra, Rb is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rd=0 & Sub5=0b00010 { Rt = Ra & Rb; }
:xor  Rt, Ra, Rb is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rd=0 & Sub5=0b00011 { Rt = Ra ^ Rb; }
:or   Rt, Ra, Rb is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rd=0 & Sub5=0b00100 { Rt = Ra | Rb; }
:nor  Rt, Ra, Rb is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rd=0 & Sub5=0b00101 { Rt = ~(Ra | Rb); }
:slt  Rt, Ra, Rb is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rd=0 & Sub5=0b00110 { Rt = zext(Ra < Rb); }
:slts Rt, Ra, Rb is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rd=0 & Sub5=0b00111 { Rt = zext(Ra s< Rb); }
:sva  Rt, Ra, Rb is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rd=0 & Sub5=0b11000 { Rt = zext(scarry(Ra, Rb)); }
:svs  Rt, Ra, Rb is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rd=0 & Sub5=0b11001 { Rt = zext(sborrow(Ra, Rb)); }
:seb  Rt, Ra     is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb=0b00000 & Rd=0 & Sub5=0b10000 { local tmp = Ra; Rt = sext(tmp:1); }
:seh  Rt, Ra     is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb=0b00000 & Rd=0 & Sub5=0b10001 { local tmp = Ra; Rt = sext(tmp:2); }
:zeb  Rt, Ra     is OpSz=0 & Opc=0b101010 & Rt & Ra & Imm15u=0xff                  { local tmp = Ra; Rt = zext(tmp:1); }
:zeh  Rt, Ra     is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb=0b00000 & Rd=0 & Sub5=0b10011 { local tmp = Ra; Rt = zext(tmp:2); }
:wsbh Rt, Ra     is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb=0b00000 & Rd=0 & Sub5=0b10100
{
    Rt = ((Ra & 0x000000ff) << 8)
       | ((Ra & 0x0000ff00) >> 8)
       | ((Ra & 0x00ff0000) << 8)
       | ((Ra & 0xff000000) >> 8);
}


### Shifter Instruction ###

:slli  Rt, Ra, Imm5u is OpSz=0 & Opc=0b100000 & Rt & Ra & Imm5u & Rd=0 & Sub5=0b01000 { Rt = Ra  << Imm5u; }
:srli  Rt, Ra, Imm5u is OpSz=0 & Opc=0b100000 & Rt & Ra & Imm5u & Rd=0 & Sub5=0b01001 { Rt = Ra  >> Imm5u; }
:srai  Rt, Ra, Imm5u is OpSz=0 & Opc=0b100000 & Rt & Ra & Imm5u & Rd=0 & Sub5=0b01010 { Rt = Ra s>> Imm5u; }
:rotri Rt, Ra, Imm5u is OpSz=0 & Opc=0b100000 & Rt & Ra & Imm5u & Rd=0 & Sub5=0b01011 { Rt = (Ra >> Imm5u) | (Ra << (32 - Imm5u)); }
:sll   Rt, Ra, Rb    is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb    & Rd=0 & Sub5=0b01100 { tmp:4 = Rb & 0b11111; Rt = Ra  << tmp; }
:srl   Rt, Ra, Rb    is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb    & Rd=0 & Sub5=0b01101 { tmp:4 = Rb & 0b11111; Rt = Ra  >> tmp; }
:sra   Rt, Ra, Rb    is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb    & Rd=0 & Sub5=0b01110 { tmp:4 = Rb & 0b11111; Rt = Ra s>> tmp; }
:rotr  Rt, Ra, Rb    is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb    & Rd=0 & Sub5=0b01111 { tmp:4 = Rb & 0b11111; Rt = (Ra >> tmp) | (Ra << (32 - tmp)); }


### Multiply Instruction ###

:mul     Rt,    Ra, Rb is OpSz=0 & Opc=0b100001 & Rt                    & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b100100 { Rt = Ra * Rb; }
:mults64 Dt,    Ra, Rb is OpSz=0 & Opc=0b100001 & Dtl=0 & Dt    & Dtr=0 & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b101000 { Dt = sext(Ra) * sext(Rb); }
:mult64 Dt,    Ra, Rb is OpSz=0 & Opc=0b100001 & Dtl=0 & Dt    & Dtr=0 & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b101001 { Dt = zext(Ra) * zext(Rb); }
:madds64 Dt,    Ra, Rb is OpSz=0 & Opc=0b100001 & Dtl=0 & Dt    & Dtr=0 & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b101010 { Dt = Dt + (sext(Ra) * sext(Rb)); }
:madd64  Dt,    Ra, Rb is OpSz=0 & Opc=0b100001 & Dtl=0 & Dt    & Dtr=0 & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b101011 { Dt = Dt + (zext(Ra) * zext(Rb)); }
:msubs64 Dt,    Ra, Rb is OpSz=0 & Opc=0b100001 & Dtl=0 & Dt    & Dtr=0 & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b101100 { Dt = Dt - (sext(Ra) * sext(Rb)); }
:msub64  Dt,    Ra, Rb is OpSz=0 & Opc=0b100001 & Dtl=0 & Dt    & Dtr=0 & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b101101 { Dt = Dt - (zext(Ra) * zext(Rb)); }
:mult32 Dt, Ra, Rb is OpSz=0 & Opc=0b100001 & Dtl=0 & Dt & Dtr=0 & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b110001 { Dt = Ra * Rb; }
:madd32  Dtlow, Ra, Rb is OpSz=0 & Opc=0b100001 & Dtl=0 & Dtlow & Dtr=0 & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b110011 { Dtlow = Dtlow + (Ra * Rb); }
:msub32  Dtlow, Ra, Rb is OpSz=0 & Opc=0b100001 & Dtl=0 & Dtlow & Dtr=0 & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b110101 { Dtlow = Dtlow - (Ra * Rb); }


# TODO : special instruction, but used get the division results
# Group 0
UsrName: d0.lo is Group=0 & Usr=0 & d0.lo { export d0.lo; }
UsrName: d0.hi is Group=0 & Usr=1 & d0.hi { export d0.hi; }
UsrName: d1.lo is Group=0 & Usr=2 & d1.lo { export d1.lo; }
UsrName: d1.hi is Group=0 & Usr=3 & d1.hi { export d1.hi; }
UsrName: itb is Group=0 & Usr=0b11100 & itb { export itb; }
UsrName: pc is Group=0 & Usr=0b11111 & itb { export pc; }
UsrName: d0.lo is Group=0 & Usr=0 & d0.lo { export d0.lo; }
# Group 1
UsrName: dma_cfg is Group=1 & Usr=0 & dma_cfg { export dma_cfg; }
UsrName: dma_gcsw is Group=1 & Usr=1 & dma_gcsw { export dma_gcsw; }
UsrName: dma_chnsel is Group=1 & Usr=2 & dma_chnsel { export dma_chnsel; }
UsrName: dma_act is Group=1 & Usr=3 & dma_act { export dma_act; }
UsrName: dma_setup is Group=1 & Usr=4 & dma_setup { export dma_setup; }
UsrName: dma_isaddr is Group=1 & Usr=5 & dma_isaddr { export dma_isaddr; }
UsrName: dma_esaddr is Group=1 & Usr=6 & dma_esaddr { export dma_esaddr; }
UsrName: dma_tcnt is Group=1 & Usr=7 & dma_tcnt { export dma_tcnt; }
UsrName: dma_status is Group=1 & Usr=8 & dma_status { export dma_status; }
UsrName: dma_2dset is Group=1 & Usr=9 & dma_2dset { export dma_2dset; }
UsrName: dma_2dsctl is Group=1 & Usr=25 & dma_2dsctl { export dma_2dsctl; }
# Group 2
UsrName: pfmc0 is Group=2 & Usr=0 & pfmc0 { export pfmc0; }
UsrName: pfmc1 is Group=2 & Usr=1 & pfmc1 { export pfmc1; }
UsrName: pfmc2 is Group=2 & Usr=2 & pfmc2 { export pfmc2; }
UsrName: pfm_ctl is Group=2 & Usr=4 & pfm_ctl { export pfm_ctl; }

:mtusr Rt, UsrName is OpSz=0 & Opc=0b100001 & Rt & UsrName & Alu2Mod=0b0000 & Sub6=0b100001 { UsrName = Rt; }
:mfusr Rt, UsrName is OpSz=0 & Opc=0b100001 & Rt & UsrName & Alu2Mod=0b0000 & Sub6=0b100000 { Rt = UsrName; }


### Divide Instructions ###

:div  Dt, Ra, Rb is OpSz=0 & Opc=0b100001 & Dtl=0 & Dt & Dtlow & Dthigh & Dtr=0 & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b101111 { Dtlow = Ra  / Rb; Dthigh = Ra  % Rb; }
:divs Dt, Ra, Rb is OpSz=0 & Opc=0b100001 & Dtl=0 & Dt & Dtlow & Dthigh & Dtr=0 & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b101110 { Dtlow = Ra s/ Rb; Dthigh = Ra s% Rb; }


### Load / Store Instruction (immediate) ###

ByteOffset: off is Imm15s [ off = Imm15s << 0; ] { export *[const]:4 off; }
HalfOffset: off is Imm15s [ off = Imm15s << 1; ] { export *[const]:4 off; }
WordOffset: off is Imm15s [ off = Imm15s << 2; ] { export *[const]:4 off; }

AddrByteRaImm15s: [Ra + ByteOffset] is Ra & ByteOffset { addr:4 = Ra + ByteOffset; export addr; }
AddrHalfRaImm15s: [Ra + HalfOffset] is Ra & HalfOffset { addr:4 = Ra + HalfOffset; export addr; }
AddrWordRaImm15s: [Ra + WordOffset] is Ra & WordOffset { addr:4 = Ra + WordOffset; export addr; }

:lwi  Rt, AddrWordRaImm15s is OpSz=0 & Opc=0b000010 & Rt & AddrWordRaImm15s { Rt = *AddrWordRaImm15s; }
:lhi  Rt, AddrHalfRaImm15s is OpSz=0 & Opc=0b000001 & Rt & AddrHalfRaImm15s { local tmp:2 = *AddrHalfRaImm15s; Rt = zext(tmp); }
:lhsi Rt, AddrHalfRaImm15s is OpSz=0 & Opc=0b010001 & Rt & AddrHalfRaImm15s { local tmp:2 = *AddrHalfRaImm15s; Rt = sext(tmp); }
:lbi  Rt, AddrByteRaImm15s is OpSz=0 & Opc=0b000000 & Rt & AddrByteRaImm15s { local tmp:1 = *AddrByteRaImm15s; Rt = zext(tmp); }
:lbsi Rt, AddrByteRaImm15s is OpSz=0 & Opc=0b010000 & Rt & AddrByteRaImm15s { local tmp:1 = *AddrByteRaImm15s; Rt = sext(tmp); }
:swi  Rt, AddrWordRaImm15s is OpSz=0 & Opc=0b001010 & Rt & AddrWordRaImm15s { *AddrWordRaImm15s = Rt; }

:shi  Rt, AddrHalfRaImm15s is OpSz=0 & Opc=0b001001 & Rt & AddrHalfRaImm15s { local tmp = Rt; *AddrHalfRaImm15s = tmp:2; }
:sbi  Rt, AddrByteRaImm15s is OpSz=0 & Opc=0b001000 & Rt & AddrByteRaImm15s { local tmp = Rt; *AddrByteRaImm15s = tmp:1; }

### Load / Store Instruction (immediate, postincr) ###

:lwi.bi  Rt, [Ra], WordOffset is OpSz=0 & Opc=0b000110 & Rt & Ra & WordOffset { Rt = *Ra; Ra = Ra + WordOffset; }
:lhi.bi  Rt, [Ra], HalfOffset is OpSz=0 & Opc=0b000101 & Rt & Ra & HalfOffset { local tmp:2 = *Ra; Rt = zext(tmp); Ra = Ra + HalfOffset; }
:lhsi.bi Rt, [Ra], HalfOffset is OpSz=0 & Opc=0b010101 & Rt & Ra & HalfOffset { local tmp:2 = *Ra; Rt = sext(tmp); Ra = Ra + HalfOffset; }
:lbi.bi  Rt, [Ra], ByteOffset is OpSz=0 & Opc=0b000100 & Rt & Ra & ByteOffset { local tmp:1 = *Ra; Rt = zext(tmp); Ra = Ra + ByteOffset; }
:lbsi.bi Rt, [Ra], ByteOffset is OpSz=0 & Opc=0b010100 & Rt & Ra & ByteOffset { local tmp:1 = *Ra; Rt = sext(tmp); Ra = Ra + ByteOffset; }
:swi.bi  Rt, [Ra], WordOffset is OpSz=0 & Opc=0b001110 & Rt & Ra & WordOffset { *Ra = Rt; Ra = Ra + WordOffset; }
:shi.bi  Rt, [Ra], HalfOffset is OpSz=0 & Opc=0b001101 & Rt & Ra & HalfOffset { local tmp = Rt; *Ra = tmp:2; Ra = Ra + HalfOffset; }
:sbi.bi  Rt, [Ra], ByteOffset is OpSz=0 & Opc=0b001100 & Rt & Ra & ByteOffset { local tmp = Rt; *Ra = tmp:1; Ra = Ra + ByteOffset; }


### Load / Store Instruction (register) ###

OffsetRbsv: (Rb "<<" sv) is Rb & sv { off:4 = Rb << sv; export off; }
AddrRaRbsv: [Ra + OffsetRbsv] is Ra & OffsetRbsv { addr:4 = Ra + OffsetRbsv; export addr; }

:lw  Rt, AddrRaRbsv is OpSz=0 & Opc=0b011100 & Rt & AddrRaRbsv & Sub8=0b00000010 { Rt = *AddrRaRbsv; }
:lh  Rt, AddrRaRbsv is OpSz=0 & Opc=0b011100 & Rt & AddrRaRbsv & Sub8=0b00000001 { local tmp:2 = *AddrRaRbsv; Rt = zext(tmp); }
:lhs Rt, AddrRaRbsv is OpSz=0 & Opc=0b011100 & Rt & AddrRaRbsv & Sub8=0b00010001 { local tmp:2 = *AddrRaRbsv; Rt = sext(tmp); }
:lb  Rt, AddrRaRbsv is OpSz=0 & Opc=0b011100 & Rt & AddrRaRbsv & Sub8=0b00000000 { local tmp:1 = *AddrRaRbsv; Rt = zext(tmp); }
:lbs Rt, AddrRaRbsv is OpSz=0 & Opc=0b011100 & Rt & AddrRaRbsv & Sub8=0b00010000 { local tmp:1 = *AddrRaRbsv; Rt = sext(tmp); }
:sw  Rt, AddrRaRbsv is OpSz=0 & Opc=0b011100 & Rt & AddrRaRbsv & Sub8=0b00001010 { *AddrRaRbsv = Rt; }
:sh  Rt, AddrRaRbsv is OpSz=0 & Opc=0b011100 & Rt & AddrRaRbsv & Sub8=0b00001001 { local tmp = Rt; *AddrRaRbsv = tmp:2; }
:sb  Rt, AddrRaRbsv is OpSz=0 & Opc=0b011100 & Rt & AddrRaRbsv & Sub8=0b00001000 { local tmp = Rt; *AddrRaRbsv = tmp:1; }


### Load / Store Instruction (register, postincr) ###

:lw.bi  Rt, [Ra], OffsetRbsv is OpSz=0 & Opc=0b011100 & Rt & Ra & OffsetRbsv & Sub8=0b00000110 { Rt = *Ra; Ra = Ra + OffsetRbsv; }
:lh.bi  Rt, [Ra], OffsetRbsv is OpSz=0 & Opc=0b011100 & Rt & Ra & OffsetRbsv & Sub8=0b00000101 { local tmp:2 = *Ra; Rt = zext(tmp); Ra = Ra + OffsetRbsv; }
:lhs.bi Rt, [Ra], OffsetRbsv is OpSz=0 & Opc=0b011100 & Rt & Ra & OffsetRbsv & Sub8=0b00010101 { local tmp:2 = *Ra; Rt = sext(tmp); Ra = Ra + OffsetRbsv; }
:lb.bi  Rt, [Ra], OffsetRbsv is OpSz=0 & Opc=0b011100 & Rt & Ra & OffsetRbsv & Sub8=0b00000100 { local tmp:1 = *Ra; Rt = zext(tmp); Ra = Ra + OffsetRbsv; }
:lbs.bi Rt, [Ra], OffsetRbsv is OpSz=0 & Opc=0b011100 & Rt & Ra & OffsetRbsv & Sub8=0b00010100 { local tmp:1 = *Ra; Rt = sext(tmp); Ra = Ra + OffsetRbsv; }
:sw.bi  Rt, [Ra], OffsetRbsv is OpSz=0 & Opc=0b011100 & Rt & Ra & OffsetRbsv & Sub8=0b00001110 { *Ra = Rt; Ra = Ra + OffsetRbsv; }
:sh.bi  Rt, [Ra], OffsetRbsv is OpSz=0 & Opc=0b011100 & Rt & Ra & OffsetRbsv & Sub8=0b00001101 { local tmp = Rt; *Ra = tmp:2; Ra = Ra + OffsetRbsv; }
:sb.bi  Rt, [Ra], OffsetRbsv is OpSz=0 & Opc=0b011100 & Rt & Ra & OffsetRbsv & Sub8=0b00001100 { local tmp = Rt; *Ra = tmp:1; Ra = Ra + OffsetRbsv; }


### Load / Store Multiple Word Instruction ###

LsmwBa_: "b" is LsmwBa=0 { }
LsmwBa_: "a" is LsmwBa=1 { }

LsmwId_: "i" is LsmwId=0 { }
LsmwId_: "d" is LsmwId=1 { }

LsmwM_: ""  is LsmwRa & LsmwM=0 { }
LsmwM_: "m" is LsmwRa & LsmwM=1 { LsmwRa = mult_addr; }


:lmw.^LsmwBa_^LsmwId_^LsmwM_ LsmwRb, [LsmwRa], LsmwRe, Enable4 is OpSz=0 & Opc=0b011101 & LsmwRb & LsmwRa & LsmwRe & Enable4 & LsmwLs=0 & LsmwBa_ & LsmwId_ & LsmwM_ & LsmwSub=0b00 
{
}

:smw.^LsmwBa_^LsmwId_^LsmwM_ LsmwRb, [LsmwRa], LsmwRe, Enable4 is OpSz=0 & Opc=0b011101 & LsmwRb & LsmwRa & LsmwRe & Enable4 & LsmwLs=1 & LsmwBa_ & LsmwId_ & LsmwM_ & LsmwSub=0b00 
{
}


### Load / Store Instruction for Atomic Updates ###

:llw Rt, AddrRaRbsv is OpSz=0 & Opc=0b011100 & Rt & AddrRaRbsv & Sub8=0b00011000 { Rt = *AddrRaRbsv; }
:scw Rt, AddrRaRbsv is OpSz=0 & Opc=0b011100 & Rt & AddrRaRbsv & Sub8=0b00011001 { *AddrRaRbsv = Rt; }


### Load / Store Instructions with User-mode Privilege ###

# TODO : special constraint (user-mode address translation)

:lwup Rt, AddrRaRbsv is OpSz=0 & Opc=0b011100 & Rt & AddrRaRbsv & Sub8=0b00100010 { Rt = *AddrRaRbsv; }
:swup Rt, AddrRaRbsv is OpSz=0 & Opc=0b011100 & Rt & AddrRaRbsv & Sub8=0b00101010 { *AddrRaRbsv = Rt; }


### Jump Instruction ###

Rel24: addr is Imm24s [ addr = inst_start + sext(Imm24s << 1); ] { export *:4 addr; }

:j    Rel24 is OpSz=0 & Opc=0b100100   & JIt=0 & Rel24 { goto Rel24; }
:jal  Rel24 is OpSz=0 & Opc=0b100100   & JIt=1 & Rel24 { lp = inst_next; call Rel24; }
:jr   Rb    is OpSz=0 & Opc=0b100101 & Rt=0 & Ra=0 & Rb & DtIt=0b00 & Jz=0 & JrHint=0 & Sub5=0b00000 { goto [Rb]; }
:ret  Rb    is OpSz=0 & Opc=0b100101 & Rt=0 & Ra=0 & Rb & DtIt=0b00 & Jz=0 & JrHint=1 & Sub5=0b00000 { return [Rb]; }
:jral Rt,Rb is OpSz=0 & Opc=0b100101 & Rt & Ra=0 & Rb & DtIt=0b00 & Jz=0 & JrHint=0 & Sub5=0b00001 { Rt = inst_next; call [Rb]; }


### Branch Instruction ###
Rel14: addr is Imm14s [ addr = inst_start + (Imm14s << 1); ] { export *:4 addr; }
Rel16: addr is Imm16s [ addr = inst_start + (Imm16s << 1); ] { export *:4 addr; }

:beq  Rt, Ra, Rel14 is OpSz=0 & Opc=0b100110 & Rt & Ra & Br1t=0 & Rel14 { if(Rt == Ra) goto Rel14; }
:bne  Rt, Ra, Rel14 is OpSz=0 & Opc=0b100110 & Rt & Ra & Br1t=1 & Rel14 { if(Rt != Ra) goto Rel14; }
:beqz Rt,     Rel16 is OpSz=0 & Opc=0b100111 & Rt & Br2t=0b0010 & Rel16 { if(Rt == 0)  goto Rel16; }
:bnez Rt,     Rel16 is OpSz=0 & Opc=0b100111 & Rt & Br2t=0b0011 & Rel16 { if(Rt != 0)  goto Rel16; }
:bgez Rt,     Rel16 is OpSz=0 & Opc=0b100111 & Rt & Br2t=0b0100 & Rel16 { if(Rt s>= 0) goto Rel16; }
:bltz Rt,     Rel16 is OpSz=0 & Opc=0b100111 & Rt & Br2t=0b0101 & Rel16 { if(Rt s< 0)  goto Rel16; }
:bgtz Rt,     Rel16 is OpSz=0 & Opc=0b100111 & Rt & Br2t=0b0110 & Rel16 { if(Rt s> 0)  goto Rel16; }
:blez Rt,     Rel16 is OpSz=0 & Opc=0b100111 & Rt & Br2t=0b0111 & Rel16 { if(Rt s<= 0) goto Rel16; }


### Branch with link Instruction ###

:bgezal Rt, Rel16 is OpSz=0 & Opc=0b100111 & Rt & Br2t=0b1100 & Rel16
{
    lp = inst_next;
    if(Rt s>= 0) goto <end>;
        call Rel16;
    <end>
}

:bltzal Rt, Rel16 is OpSz=0 & Opc=0b100111 & Rt & Br2t=0b1101 & Rel16
{
    lp = inst_next;
    if(Rt s< 0) goto <end>;
        call Rel16;
    <end>
}


### Read / Write System Registers ###

# TODO : special instruction, do we create the system registers ?
define pcodeop mfsr;
define pcodeop mtsr;

SysRegName: cpu_ver is SrIdx=0 & cpu_ver { export cpu_ver; }
SysRegName: core_id is SrIdx=1 & core_id { export core_id; }
SysRegName: icm_cfg is SrIdx=8 & icm_cfg { export icm_cfg; }
SysRegName: dcm_cfg is SrIdx=16 & dcm_cfg { export dcm_cfg; }
SysRegName: mmu_cfg is SrIdx=24 & mmu_cfg { export mmu_cfg; }
SysRegName: msc_cfg is SrIdx=32 & msc_cfg { export msc_cfg; }
SysRegName: psw is SrIdx=128 & psw { export psw; }
SysRegName: ipsw is SrIdx=129 & ipsw { export ipsw; }
SysRegName: p_ipsw is SrIdx=130 & p_ipsw { export p_ipsw; }
SysRegName: ivb is SrIdx=137 & ivb { export ivb; }
SysRegName: int_ctrl is SrIdx=138 & int_ctrl { export int_ctrl; }
SysRegName: eva is SrIdx=145 & eva { export eva; }
SysRegName: p_eva is SrIdx=146 & p_eva { export p_eva; }
SysRegName: itype is SrIdx=153 & itype { export itype; }
SysRegName: p_itype is SrIdx=154 & p_itype { export p_itype; }
SysRegName: merr is SrIdx=161 & merr { export merr; }
SysRegName: ipc is SrIdx=169 & ipc { export ipc; }
SysRegName: p_ipc is SrIdx=170 & p_ipc { export p_ipc; }
SysRegName: oipc is SrIdx=171 & oipc { export oipc; }
SysRegName: p_p0 is SrIdx=178 & p_p0 { export p_p0; }
SysRegName: p_p1 is SrIdx=186 & p_p1 { export p_p1; }
SysRegName: int_mask is SrIdx=192 & int_mask { export int_mask; }
SysRegName: int_mask2 is SrIdx=193 & int_mask2 { export int_mask2; }
SysRegName: int_pend is SrIdx=200 & int_pend { export int_pend; }
SysRegName: int_pend2 is SrIdx=201 & int_pend2 { export int_pend2; }
SysRegName: int_trigger is SrIdx=204 & int_trigger { export int_trigger; }
SysRegName: sp_usr is SrIdx=208 & sp_usr { export sp_usr; }
SysRegName: sp_priv is SrIdx=209 & sp_priv { export sp_priv; }
SysRegName: int_pri is SrIdx=216 & int_pri { export int_pri; }
SysRegName: int_pri2 is SrIdx=217 & int_pri2 { export int_pri2; }
SysRegName: mmu_ctl is SrIdx=256 & mmu_ctl { export mmu_ctl; }
SysRegName: l1_pptb is SrIdx=264 & l1_pptb { export l1_pptb; }
SysRegName: tlb_vpn is SrIdx=272 & tlb_vpn { export tlb_vpn; }
SysRegName: tlb_data is SrIdx=280 & tlb_data { export tlb_data; }
SysRegName: tlb_misc is SrIdx=288 & tlb_misc { export tlb_misc; }
SysRegName: vlpt_idx is SrIdx=296 & vlpt_idx { export vlpt_idx; }
SysRegName: ilmb is SrIdx=304 & ilmb { export ilmb; }
SysRegName: dlmb is SrIdx=312 & dlmb { export dlmb; }
SysRegName: cache_ctl is SrIdx=320 & cache_ctl { export cache_ctl; }
SysRegName: hsmp_saddr is SrIdx=328 & hsmp_saddr { export hsmp_saddr; }
SysRegName: hsmp_eaddr is SrIdx=329 & hsmp_eaddr { export hsmp_eaddr; }
SysRegName: sdz_ctl is SrIdx=376 & sdz_ctl { export sdz_ctl; }
SysRegName: misc_ctl is SrIdx=377 & misc_ctl { export misc_ctl; }
SysRegName: fucpr is SrIdx=552 & fucpr { export fucpr; }
SysRegName: bpc0 is SrIdx=384 & bpc0 { export bpc0; }
SysRegName: bpc1 is SrIdx=385 & bpc1 { export bpc1; }
SysRegName: bpc2 is SrIdx=386 & bpc2 { export bpc2; }
SysRegName: bpc3 is SrIdx=387 & bpc3 { export bpc3; }
SysRegName: bpc4 is SrIdx=388 & bpc4 { export bpc4; }
SysRegName: bpc5 is SrIdx=389 & bpc5 { export bpc5; }
SysRegName: bpc6 is SrIdx=390 & bpc6 { export bpc6; }
SysRegName: bpc7 is SrIdx=391 & bpc7 { export bpc7; }
SysRegName: bpa0 is SrIdx=392 & bpa0 { export bpa0; }
SysRegName: bpa1 is SrIdx=393 & bpa1 { export bpa1; }
SysRegName: bpa2 is SrIdx=394 & bpa2 { export bpa2; }
SysRegName: bpa3 is SrIdx=395 & bpa3 { export bpa3; }
SysRegName: bpa4 is SrIdx=396 & bpa4 { export bpa4; }
SysRegName: bpa5 is SrIdx=397 & bpa5 { export bpa5; }
SysRegName: bpa6 is SrIdx=398 & bpa6 { export bpa6; }
SysRegName: bpa7 is SrIdx=399 & bpa7 { export bpa7; }
SysRegName: bpam0 is SrIdx=400 & bpam0 { export bpam0; }
SysRegName: bpam1 is SrIdx=401 & bpam1 { export bpam1; }
SysRegName: bpam2 is SrIdx=402 & bpam2 { export bpam2; }
SysRegName: bpam3 is SrIdx=403 & bpam3 { export bpam3; }
SysRegName: bpam4 is SrIdx=404 & bpam4 { export bpam4; }
SysRegName: bpam5 is SrIdx=405 & bpam5 { export bpam5; }
SysRegName: bpam6 is SrIdx=406 & bpam6 { export bpam6; }
SysRegName: bpam7 is SrIdx=407 & bpam7 { export bpam7; }
SysRegName: bpv0 is SrIdx=408 & bpv0 { export bpv0; }
SysRegName: bpv1 is SrIdx=409 & bpv1 { export bpv1; }
SysRegName: bpv2 is SrIdx=410 & bpv2 { export bpv2; }
SysRegName: bpv3 is SrIdx=411 & bpv3 { export bpv3; }
SysRegName: bpv4 is SrIdx=412 & bpv4 { export bpv4; }
SysRegName: bpv5 is SrIdx=413 & bpv5 { export bpv5; }
SysRegName: bpv6 is SrIdx=414 & bpv6 { export bpv6; }
SysRegName: bpv7 is SrIdx=415 & bpv7 { export bpv7; }
SysRegName: bpcid0 is SrIdx=416 & bpcid0 { export bpcid0; }
SysRegName: bpcid1 is SrIdx=417 & bpcid1 { export bpcid1; }
SysRegName: bpcid2 is SrIdx=418 & bpcid2 { export bpcid2; }
SysRegName: bpcid3 is SrIdx=419 & bpcid3 { export bpcid3; }
SysRegName: bpcid4 is SrIdx=420 & bpcid4 { export bpcid4; }
SysRegName: bpcid5 is SrIdx=421 & bpcid5 { export bpcid5; }
SysRegName: bpcid6 is SrIdx=422 & bpcid6 { export bpcid6; }
SysRegName: bpcid7 is SrIdx=423 & bpcid7 { export bpcid7; }
SysRegName: edm_cfg is SrIdx=424 & edm_cfg { export edm_cfg; }
SysRegName: edmsw is SrIdx=432 & edmsw { export edmsw; }
SysRegName: edm_ctl is SrIdx=440 & edm_ctl { export edm_ctl; }
SysRegName: edm_dtr is SrIdx=448 & edm_dtr { export edm_dtr; }
SysRegName: bpmtc is SrIdx=456 & bpmtc { export bpmtc; }
SysRegName: dimbr is SrIdx=464 & dimbr { export dimbr; }
SysRegName: tecr0 is SrIdx=496 & tecr0 { export tecr0; }
SysRegName: tecr1 is SrIdx=497 & tecr1 { export tecr1; }
SysRegName: pfmc0 is SrIdx=512 & pfmc0 { export pfmc0; }
SysRegName: pfmc1 is SrIdx=513 & pfmc1 { export pfmc1; }
SysRegName: pfmc2 is SrIdx=514 & pfmc2 { export pfmc2; }
SysRegName: pfm_ctl is SrIdx=520 & pfm_ctl { export pfm_ctl; }
SysRegName: prusr_acc_ctl is SrIdx=544 & prusr_acc_ctl { export prusr_acc_ctl; }
SysRegName: dma_cfg is SrIdx=640 & dma_cfg { export dma_cfg; }
SysRegName: dma_gcsw is SrIdx=648 & dma_gcsw { export dma_gcsw; }
SysRegName: dma_chnsel is SrIdx=656 & dma_chnsel { export dma_chnsel; }
SysRegName: dma_act is SrIdx=664 & dma_act { export dma_act; }
SysRegName: dma_setup is SrIdx=672 & dma_setup { export dma_setup; }
SysRegName: dma_isaddr is SrIdx=680 & dma_isaddr { export dma_isaddr; }
SysRegName: dma_esaddr is SrIdx=688 & dma_esaddr { export dma_esaddr; }
SysRegName: dma_tcnt is SrIdx=696 & dma_tcnt { export dma_tcnt; }
SysRegName: dma_status is SrIdx=704 & dma_status { export dma_status; }
SysRegName: dma_2dset is SrIdx=712 & dma_2dset { export dma_2dset; }
SysRegName: dma_2dsctl is SrIdx=713 & dma_2dsctl { export dma_2dsctl; }

:mfsr Rt, SysRegName is OpSz=0 & Opc=0b110010 & Rt & SysRegName & Rd=0 & Sub5=0b00010 { }
:mtsr Rt, SysRegName is OpSz=0 & Opc=0b110010 & Rt & SysRegName & Rd=0 & Sub5=0b00011 { }


### Jump Register with System Register Update ###

# TODO : special constraint (address translation off)

:jr.itoff  Rb    is OpSz=0 & Opc=0b100101 & Rt=0 & Ra=0 & Rb & DtIt=0b01 & Jz=0 & JrHint=0 & Sub5=0b00000 { goto [Rb]; }
:jr.toff   Rb    is OpSz=0 & Opc=0b100101 & Rt=0 & Ra=0 & Rb & DtIt=0b11 & Jz=0 & JrHint=0 & Sub5=0b00000 { goto [Rb]; }
:jral.iton Rt,Rb is OpSz=0 & Opc=0b100101 & Rt   & Ra=0 & Rb & DtIt=0b01 & Jz=0 & JrHint=0 & Sub5=0b00001 { Rt = inst_next; call [Rb]; }
:jral.ton  Rt,Rb is OpSz=0 & Opc=0b100101 & Rt   & Ra=0 & Rb & DtIt=0b11 & Jz=0 & JrHint=0 & Sub5=0b00001 { Rt = inst_next; call [Rb]; }


### MMU Instruction ###

define pcodeop TLB_TargetRead;
define pcodeop TLB_TargetWrite;
define pcodeop TLB_RWrite;
define pcodeop TLB_RWriteLock;
define pcodeop TLB_Unlock;
define pcodeop TLB_Probe;
define pcodeop TLB_Invalidate;
define pcodeop TLB_FlushAll;

:tlbop Ra,"TargetRead"  is OpSz=0 & Opc=0b110010 & Rt & Ra & Rb=0 & TlbopSub=0 & Sub5=0b01110 { TLB_TargetRead(Ra:4); }
:tlbop Ra,"TargetWrite" is OpSz=0 & Opc=0b110010 & Rt & Ra & Rb=0 & TlbopSub=1 & Sub5=0b01110 { TLB_TargetWrite(Ra:4); }
:tlbop Ra,"RWrite"      is OpSz=0 & Opc=0b110010 & Rt & Ra & Rb=0 & TlbopSub=2 & Sub5=0b01110 { TLB_RWrite(Ra:4); }
:tlbop Ra,"RWriteLock"  is OpSz=0 & Opc=0b110010 & Rt & Ra & Rb=0 & TlbopSub=3 & Sub5=0b01110 { TLB_RWriteLock(Ra:4); }
:tlbop Ra,"Unlock"      is OpSz=0 & Opc=0b110010 & Rt & Ra & Rb=0 & TlbopSub=4 & Sub5=0b01110 { TLB_Unlock(Ra:4); }
:tlbop Rt,Ra,"Probe"    is OpSz=0 & Opc=0b110010 & Rt & Ra & Rb=0 & TlbopSub=5 & Sub5=0b01110 { TLB_Probe(Rt:4, Ra:4); }
:tlbop Ra,"Invalidate"  is OpSz=0 & Opc=0b110010 & Rt & Ra & Rb=0 & TlbopSub=6 & Sub5=0b01110 { TLB_Invalidate(Ra:4); }
:tlbop "FlushAll"       is OpSz=0 & Opc=0b110010 & Rt & Ra & Rb=0 & TlbopSub=7 & Sub5=0b01110 { TLB_FlushAll(); }


### Conditional Move ###

:cmovz Rt, Ra, Rb is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rd=0 & Sub5=0b11010
{
    if(Rb != 0) goto <end>;
        Rt = Ra;
    <end>
}

:cmovn Rt, Ra, Rb is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rd=0 & Sub5=0b11011
{
    if(Rb == 0) goto <end>;
        Rt = Ra;
    <end>
}


### Synchronization Instruction ###

# TODO : special function, and subfunctions

define pcodeop msync;
define pcodeop isync;

:msync MsyncSub is OpSz=0 & Opc=0b110010 & Rt=0 & MsyncZ=0 & MsyncSub & Sub5=0b01100 { msync(MsyncSub:1); }
:isync Rt       is OpSz=0 & Opc=0b110010 & Rt & Ra=0 & Rb=0 & Rd=0    & Sub5=0b01101 { isync(Rt:4); }

### Prefetch Instruction ###

define pcodeop dpref;

OffsetRbsv2: (Rb "<<" sv) is Rb & sv { off:4 = Rb << (sv + 1); export off; }
AddrRaRbsv2: [Ra + OffsetRbsv2] is Ra & OffsetRbsv2 { addr:4 = Ra + OffsetRbsv2; export addr; }

:dpref DprefSub, AddrRaRbsv2 is OpSz=0 & Opc=0b011100 & DprefD=0 & DprefSub & AddrRaRbsv2 & Sub8=0b00010011 {
    dpref(DprefSub:1, AddrRaRbsv2:4);
}

DprefD_: "w" is DprefD=0 { }
DprefD_: "d" is DprefD=1 { }

DprefiAddr: [Ra + Offset] is DprefD=0 & Ra & Imm15s [ Offset = Imm15s << 2; ] { export *[const]:4 Offset; }
DprefiAddr: [Ra + Offset] is DprefD=1 & Ra & Imm15s [ Offset = Imm15s << 3; ] { export *[const]:4 Offset; }

:dprefi.^DprefD_ DprefSub, DprefiAddr is OpSz=0 & Opc=0b010011 & DprefD_ & DprefSub & DprefiAddr {
    dpref(DprefSub:1, DprefiAddr:4);
}


### NOP Instruction ###

:nop is OpSz=0 & Opc=0b100000 & Rt=0 & Ra=0 & Imm5u=0 & Rd=0 & Sub5=0b01001 { }


### Serialization Instruction ###

define pcodeop dsb;
define pcodeop isb;

:dsb is OpSz=0 & Opc=0b110010 & Rt=0 & Ra=0 & Rb=0 & Rd=0 & Sub5=0b01000 { dsb(); }
:isb is OpSz=0 & Opc=0b110010 & Rt=0 & Ra=0 & Rb=0 & Rd=0 & Sub5=0b01001 { isb(); }


### Exception Generation Instruction ###

define pcodeop break;
define pcodeop syscall;
define pcodeop trap;

:break   Swid is OpSz=0 & Opc=0b110010 & Rt=0 & Swid & Sub5=0b01010 { break(Swid:4); }
:syscall Swid is OpSz=0 & Opc=0b110010 & Rt=0 & Swid & Sub5=0b01011 { syscall(Swid:4); }
:trap    Swid is OpSz=0 & Opc=0b110010 & Rt=0 & Swid & Sub5=0b00101 { trap(Swid:4); }

:teqz Rt, Swid is OpSz=0 & Opc=0b110010 & Rt & Swid & Sub5=0b00110
{
    if(Rt != 0) goto <end>;
        trap(Swid:4);
    <end>
}

:tnez Rt, Swid is OpSz=0 & Opc=0b110010 & Rt & Swid & Sub5=0b00111
{
    if(Rt == 0) goto <end>;
        trap(Swid:4);
    <end>
}


### Special Return Instruction ###

:iret is OpSz=0 & Opc=0b110010 & Rt=0 & Ra=0 & Rb=0 & Rd=0 & Sub5=0b00100 { return [ipc]; }

# TODO : special constraint (address translation off)
:ret.itoff Rb is OpSz=0 & Opc=0b100101 & Rt=0 & Ra=0 & Rb & DtIt=0b01 & Jz=0 & JrHint=1 & Sub5=0b00000 { return [Rb]; }
:ret.toff  Rb is OpSz=0 & Opc=0b100101 & Rt=0 & Ra=0 & Rb & DtIt=0b11 & Jz=0 & JrHint=1 & Sub5=0b00000 { return [Rb]; }


### Cache Control Instruction ###

# TODO : special function, with subfunctions
define pcodeop cctl;

CctlSubLevel: "1LEVEL" is CctlLevel=0 {}
CctlSubLevel: "2LEVEL" is CctlLevel=1 {}

CctlSubEnc: Rt, "L1D_VA_INVAL", CctlSubLevel   is Rt & CctlSub20=0b000 & CctlSub43=0b01 & CctlSubLevel {}
CctlSubEnc: Rt, "L1I_VA_INVAL", CctlSubLevel   is Rt & CctlSub20=0b000 & CctlSub43=0b11 & CctlSubLevel {}
CctlSubEnc: Rt, "L1D_VA_WB", CctlSubLevel      is Rt & CctlSub20=0b001 & CctlSub43=0b01 & CctlSubLevel {}

CctlSubEnc: Rt, "L1D_VA_WBINVAL", CctlSubLevel is Rt & CctlSub20=0b010 & CctlSub43=0b01 & CctlSubLevel {}
CctlSubEnc: Rt, "L1D_VA_FILLCK", CctlSubLevel  is Rt & CctlSub20=0b011 & CctlSub43=0b01 & CctlSubLevel {}
CctlSubEnc: Rt, "L1I_VA_FILLCK", CctlSubLevel  is Rt & CctlSub20=0b011 & CctlSub43=0b11 & CctlSubLevel {}
CctlSubEnc: Rt, "L1D_VA_ULCK", CctlSubLevel    is Rt & CctlSub20=0b100 & CctlSub43=0b01 & CctlSubLevel {}
CctlSubEnc: Rt, "L1I_VA_ULCK", CctlSubLevel    is Rt & CctlSub20=0b100 & CctlSub43=0b11 & CctlSubLevel {}

CctlSubEnc: Rt, "L1D_IX_INVAL"   is Rt & CctlSub20=0b000 & CctlSub43=0b00 {}
CctlSubEnc: Rt, "L1I_IX_INVAL"   is Rt & CctlSub20=0b000 & CctlSub43=0b10 {}

CctlSubEnc: Rt, "L1D_IX_WB"      is Rt & CctlSub20=0b001 & CctlSub43=0b00 {}

CctlSubEnc: Rt, "L1D_IX_WBINVAL" is Rt & CctlSub20=0b010 & CctlSub43=0b00 {}

CctlSubEnc: Rt, "L1D_IX_RTAG"    is Rt & CctlSub20=0b011 & CctlSub43=0b00 {}
CctlSubEnc: Rt, "L1I_IX_RTAG"    is Rt & CctlSub20=0b011 & CctlSub43=0b10 {}

CctlSubEnc: Rt, "L1D_IX_RWD"     is Rt & CctlSub20=0b100 & CctlSub43=0b00 {}
CctlSubEnc: Rt, "L1I_IX_RWD"     is Rt & CctlSub20=0b100 & CctlSub43=0b10 {}

CctlSubEnc: Rt, "L1D_IX_WTAG"    is Rt & CctlSub20=0b101 & CctlSub43=0b00 {}
CctlSubEnc: Rt, "L1I_IX_WTAG"    is Rt & CctlSub20=0b101 & CctlSub43=0b10 {}

CctlSubEnc: Rt, "L1D_IX_WWD"     is Rt & CctlSub20=0b110 & CctlSub43=0b00 {}
CctlSubEnc: Rt, "L1I_IX_WWD"     is Rt & CctlSub20=0b110 & CctlSub43=0b10 {}

CctlSubEnc: Rt, "L1I_IX_WWD"     is Rt & CctlSub20=0b110 & CctlSub43=0b10 {}

CctlSubEnc: "L1D_WBALL", CctlSubLevel is CctlSub20=0b111 & CctlSub43=0b01 & CctlSubLevel {}

CctlSubEnc: "L1D_INVALALL"        is CctlSub20=0b111 & CctlSub43=0b00 {}

CctlSubEnc: Rt, Ra, CctlLevel, CctlSub is Rt & Ra & CctlLevel & CctlSub {}

:cctl CctlSubEnc is OpSz=0 & Opc=0b110010 & Rt & Ra & CctlZ=0 & CctlLevel & CctlSub & Sub5=0b00001 & CctlSubEnc { cctl(Rt:4, Ra:4, CctlLevel:1, CctlSub:1); }

# Miscellaneous Instructions (Baseline)

# TODO : special function. Not sure if we use context or registers for this.

define pcodeop setgie;

SetgieEN: "d" is Toggle=0 { setgie(0:1); }
SetgieEN: "e" is Toggle=1 { setgie(1:1); }

:setgie.^SetgieEN is OpSz=0 & Opc=0b110010 & ToggleL=0 & SetgieEN & SrIdx=0b0010000000 & Rd=0b00010 & Sub5=0b00011 { }

define pcodeop setend;

SetendBE: "l" is Toggle=0 { setend(0:1); }
SetendBE: "b" is Toggle=1 { setend(1:1); }

:setend.^SetendBE is OpSz=0 & Opc=0b110010 & ToggleL=0 & SetendBE & SrIdx=0b0010000000 & Rd=0b00001 & Sub5=0b00011 { }

:standby StandbySub is OpSz=0 & Opc=0b110010 & Rt=0 & Ra=0 & Rb=0 & StandbyZ=0 & StandbySub & Sub5=0b00000 { goto inst_start; }



### 32-bit Baseline V2 instructions ###

### ALU Instructions ###

:addi.gp Rt, Imm19s is OpSz=0 & Opc=0b011111 & Rt & GpSub1=0b1 & Imm19s { Rt = gp + Imm19s; }


### Multiply and Divide Instructions (V2) ###

:mulr64 Rt, Ra, Rb is OpSz=0 & Opc=0b100001 & Rt & Ra & Rb & Alu2Mod=0b0001 & Sub6=0b101001 & Rtl & Rth
{
    res:8 = zext(Ra) * zext(Rb);
#@if ENDIAN == "big"
#    Rtl = res(4);
#    Rth = res:4;
#@else
    Rtl = res:4;
    Rth = res(4);
#@endif
}

:mulsr64 Rt, Ra, Rb is OpSz=0 & Opc=0b100001 & Rt & Ra & Rb & Alu2Mod=0b0001 & Sub6=0b101000 & Rtl & Rth
{
    res:8 = sext(Ra) * sext(Rb);
#@if ENDIAN == "big"
#    Rtl = res(4);
#    Rth = res:4;
#@else
    Rtl = res:4;
    Rth = res(4);
#@endif
}

:maddr32 Rt, Ra, Rb is OpSz=0 & Opc=0b100001 & Rt & Ra & Rb & Alu2Mod=0b0001 & Sub6=0b110011 { Rt = Rt + (Ra * Rb); }
:msubr32 Rt, Ra, Rb is OpSz=0 & Opc=0b100001 & Rt & Ra & Rb & Alu2Mod=0b0001 & Sub6=0b110101 { Rt = Rt - (Ra * Rb); }
:divr    Rt, Rs, Ra, Rb is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rs & Sub5=0b10111 { local div = Ra / Rb; local mod = Ra % Rb; Rs = mod; Rt = div; }
:divsr   Rt, Rs, Ra, Rb is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rs & Sub5=0b10110 { local div = Ra s/ Rb; local mod = Ra s% Rb; Rs = mod; Rt = div; }


### Load/Store Instructions ###

GpByteAddress: [+ off] is Imm19s [ off = Imm19s << 0; ] { addr:4 = gp + off; export addr; }
GpHalfAddress: [+ off] is Imm18s [ off = Imm18s << 1; ] { addr:4 = gp + off; export addr; }
GpWordAddress: [+ off] is Imm17s [ off = Imm17s << 2; ] { addr:4 = gp + off; export addr; }

:lbi.gp Rt,  GpByteAddress is OpSz=0 & Opc=0b010111 & Rt & GpSub1=0b0   & GpByteAddress { local tmp:1 = *GpByteAddress; Rt = zext(tmp); }
:lbsi.gp Rt, GpByteAddress is OpSz=0 & Opc=0b010111 & Rt & GpSub1=0b1   & GpByteAddress { local tmp:1 = *GpByteAddress; Rt = sext(tmp); }
:lhi.gp Rt,  GpHalfAddress is OpSz=0 & Opc=0b011110 & Rt & GpSub2=0b00  & GpHalfAddress { local tmp:2 = *GpHalfAddress; Rt = zext(tmp); }
:lhsi.gp Rt, GpHalfAddress is OpSz=0 & Opc=0b011110 & Rt & GpSub2=0b01  & GpHalfAddress { local tmp:2 = *GpHalfAddress; Rt = sext(tmp); }
:lwi.gp Rt,  GpWordAddress is OpSz=0 & Opc=0b011110 & Rt & GpSub3=0b110 & GpWordAddress { Rt = *GpWordAddress; }
:sbi.gp Rt,  GpByteAddress is OpSz=0 & Opc=0b011111 & Rt & GpSub1=0b0   & GpByteAddress { local tmp = Rt; *GpByteAddress = tmp:1; }
:shi.gp Rt,  GpHalfAddress is OpSz=0 & Opc=0b011110 & Rt & GpSub2=0b10  & GpHalfAddress { local tmp = Rt; *GpHalfAddress = tmp:2; }
:swi.gp Rt,  GpWordAddress is OpSz=0 & Opc=0b011110 & Rt & GpSub3=0b111 & GpWordAddress { *GpWordAddress = Rt; }

# TODO : same as lmw/smw, this is horrible

:lmwa.^LsmwBa_^LsmwId_^LsmwM_ LsmwRb, [LsmwRa], LsmwRe, Enable4 is OpSz=0 & Opc=0b011101 & LsmwRb & LsmwRa & LsmwRe & Enable4 & LsmwLs=0 & LsmwBa_ & LsmwId_ & LsmwM_ & LsmwSub=0b01 
{
}

:smwa.^LsmwBa_^LsmwId_^LsmwM_ LsmwRb, [LsmwRa], LsmwRe, Enable4 is OpSz=0 & Opc=0b011101 & LsmwRb & LsmwRa & LsmwRe & Enable4 & LsmwLs=1 & LsmwBa_ & LsmwId_ & LsmwM_ & LsmwSub=0b01
{
}

:lbup Rt, AddrRaRbsv is OpSz=0 & Opc=0b011100 & Rt & AddrRaRbsv & Sub8=0b00100000 { local tmp:1 = *AddrRaRbsv; Rt = zext(tmp); }
:sbup Rt, AddrRaRbsv is OpSz=0 & Opc=0b011100 & Rt & AddrRaRbsv & Sub8=0b00101000 { local tmp = Rt; *AddrRaRbsv = tmp:1; }

#@endif



### 32-bit Baseline V3 instructions ###

#@if defined(BASELINE_V3)

### ALU Instructions with Shift Operation (v3) ###

:add_slli Rt, Ra, Rb, sh is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & sh & Sub5=0b00000 { Rt = Ra + (Rb << sh); }
:and_slli Rt, Ra, Rb, sh is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & sh & Sub5=0b00010 { Rt = Ra & (Rb << sh); }
:or_slli  Rt, Ra, Rb, sh is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & sh & Sub5=0b00100 { Rt = Ra | (Rb << sh); }
:sub_slli Rt, Ra, Rb, sh is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & sh & Sub5=0b00001 { Rt = Ra - (Rb << sh); }
:xor_slli Rt, Ra, Rb, sh is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & sh & Sub5=0b00011 { Rt = Ra ^ (Rb << sh); }

:add_srli Rt, Ra, Rb, sh is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & sh & Sub5=0b11100 { Rt = Ra + (Rb << sh); }
:and_srli Rt, Ra, Rb, sh is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & sh & Sub5=0b11110 { Rt = Ra & (Rb << sh); }
:or_srli  Rt, Ra, Rb, sh is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & sh & Sub5=0b10101 { Rt = Ra | (Rb << sh); }
:sub_srli Rt, Ra, Rb, sh is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & sh & Sub5=0b11101 { Rt = Ra - (Rb << sh); }
:xor_srli Rt, Ra, Rb, sh is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & sh & Sub5=0b11111 { Rt = Ra ^ (Rb << sh); }

### Conditional Branch and Jump Instructions (V3) ###

Rel8: addr is Imm8s [ addr = inst_start + sext(Imm8s << 1); ] { export *:4 addr; }
:beqc  Rt, Imm11s, Rel8 is OpSz=0 & Opc=0b101101 & Rt & Bxxc=0 & Imm11s & Rel8 { if(Rt == Imm11s) goto Rel8; }
:bnec  Rt, Imm11s, Rel8 is OpSz=0 & Opc=0b101101 & Rt & Bxxc=1 & Imm11s & Rel8 { if(Rt != Imm11s) goto Rel8; }

:jralnez Rt,Rb is OpSz=0 & Opc=0b100101 & Rt & Ra=0 & Rb & DtIt=0b00 & Jz=0 & JrHint=0 & Sub5=0b00011 { if(Rb == 0) goto <end>; Rt = inst_next; call [Rb]; <end> }
:jrnez   Rb    is OpSz=0 & Opc=0b100101 & Rt=0 & Ra=0 & Rb & DtIt=0b00 & Jz=0 & JrHint=0 & Sub5=0b00010 { if(Rb == 0) goto <end>; goto [Rb]; <end> }

### Bit Manipulation Instructions (V3) ###

:bitc  Rt, Ra, Rb     is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rd=0 & Sub5=0b10010 { Rt = Ra & (~Rb); }
:bitci Rt, Ra, Imm15u is OpSz=0 & Opc=0b110011 & Rt & Ra & Imm15u { Rt = Ra & (~Imm15u); }

### Cache Control Instruction (V3) ###

# TODO: Add CCTL L1D_WBALL, level

#@endif



### 32-bit ISA extension ###

### ALU Instruction (Performance) ###

#@if defined(PERFORMANCE_V1)

:abs Rt, Ra is OpSz=0 & Opc=0b100001 & Rt & Ra & Rb=0 & Alu2Mod=0b0000 & Sub6=0b000011
{
    gez:4 = zext(Ra s>= 0);
    ltz:4 = zext(Ra s< 0);
    Rt = (Ra * gez) | ((-Ra) * ltz);
}

:ave Rt, Ra, Rb is OpSz=0 & Opc=0b100001 & Rt & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b000010
{
    Rt = (Ra + Rb + 1) s>> 2;
}

:max Rt, Ra, Rb is OpSz=0 & Opc=0b100001 & Rt & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b000000
{
    altb:4 = zext(Ra s< Rb);
    ageb:4 = zext(Ra s>= Rb);
    Rt = (Ra * ageb) | (Rb * altb);
}

:min Rt, Ra, Rb is OpSz=0 & Opc=0b100001 & Rt & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b000001
{
    altb:4 = zext(Ra s< Rb);
    ageb:4 = zext(Ra s>= Rb);
    Rt = (Ra * altb) | (Rb * ageb);
}

:bset Rt, Ra, Imm5u is OpSz=0 & Opc=0b100001 & Rt & Ra & Imm5u & Alu2Mod=0b0000 & Sub6=0b001000 { Rt = Ra | (1 << Imm5u); }
:bclr Rt, Ra, Imm5u is OpSz=0 & Opc=0b100001 & Rt & Ra & Imm5u & Alu2Mod=0b0000 & Sub6=0b001001 { Rt = Ra & ~(1 << Imm5u); }
:btgl Rt, Ra, Imm5u is OpSz=0 & Opc=0b100001 & Rt & Ra & Imm5u & Alu2Mod=0b0000 & Sub6=0b001010 { Rt = Ra ^ (1 << Imm5u); }
:btst Rt, Ra, Imm5u is OpSz=0 & Opc=0b100001 & Rt & Ra & Imm5u & Alu2Mod=0b0000 & Sub6=0b001011 { Rt = (Ra >> Imm5u) & 1; }

:clips Rt, Ra, Imm5u is OpSz=0 & Opc=0b100001 & Rt & Ra & Imm5u & Alu2Mod=0b0000 & Sub6=0b000100
{
    local upper:4 = (1 << Imm5u) - 1;
    local lower:4 = -(1 << Imm5u);
    if(Ra s<= upper) goto <elif>;
        Rt = upper;
        goto <end>;
    <elif>
    if(Ra s>= lower) goto <else>;
        Rt = lower;
        goto <end>;
    <else>
        Rt = Ra;
    <end>
}
:clip Rt, Ra, Imm5u is OpSz=0 & Opc=0b100001 & Rt & Ra & Imm5u & Alu2Mod=0b0000 & Sub6=0b000101
{
    local upper:4 = (1 << Imm5u) - 1;
    if(Ra s<= upper) goto <elif>;
        Rt = upper;
        goto <end>;
    <elif>
    if(Ra s>= 0) goto <else>;
        Rt = 0;
        goto <end>;
    <else>
        Rt = Ra;
    <end>
}

:clz Rt, Ra is OpSz=0 & Opc=0b100001 & Rt & Ra & Imm5u=0 & Alu2Mod=0b0000 & Sub6=0b000111
{
  countTmp:4 = 0;
  inputTmp:4 = Ra;

 <loopbegin>
  if ((inputTmp & 0x80000000) != 0) goto <loopend>;

  countTmp = countTmp + 1;
  inputTmp = (inputTmp << 1) | 1;
  goto <loopbegin>;

 <loopend>
  Rt = countTmp;
}

:clo Rt, Ra is OpSz=0 & Opc=0b100001 & Rt & Ra & Imm5u=0 & Alu2Mod=0b0000 & Sub6=0b000110
{
  countTmp:4 = 0;
  inputTmp:4 = Ra;

 <loopbegin>
  if ((inputTmp & 0x80000000) == 0) goto <loopend>;

  countTmp = countTmp + 1;
  inputTmp = (inputTmp << 1) | 1;
  goto <loopbegin>;

 <loopend>
  Rt = countTmp;
}

#@endif


### Performance Extension V2 ###

#if defined(PERFORMANCE_V2)

# TODO : arithmetic functions: bs*
:bse Rt, Ra, Rb is OpSz=0 & Opc=0b100001 & Rt & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b001100 unimpl
:bsp Rt, Ra, Rb is OpSz=0 & Opc=0b100001 & Rt & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b001101 unimpl

macro add_abs_diff(dst, src1, src2, shift)
{
    local src1_ = src1 >> shift;
    local src2_ = src2 >> shift;
    local src1__ = src1_:1;
    local src2__ = src2_:1;
    local a:1 = src1__ - src2__;
    local agez:1 = zext(a s>= 0);
    local altz:1 = zext(a s< 0);
    local aabs:1 = (a * agez) | ((-a) * altz);
    dst = dst + zext(aabs);
}
:pbsad Rt, Ra, Rb is OpSz=0 & Opc=0b111000 & Rt & Ra & Rb & Rd=0 & Sub5=0b0000
{
    Rt = 0;
    add_abs_diff(Rt, Ra, Rb, 0);
    add_abs_diff(Rt, Ra, Rb, 8);
    add_abs_diff(Rt, Ra, Rb, 16);
    add_abs_diff(Rt, Ra, Rb, 24);
}
:pbsada Rt, Ra, Rb is OpSz=0 & Opc=0b111000 & Rt & Ra & Rb & Rd=0 & Sub5=0b0001
{
    add_abs_diff(Rt, Ra, Rb, 0);
    add_abs_diff(Rt, Ra, Rb, 8);
    add_abs_diff(Rt, Ra, Rb, 16);
    add_abs_diff(Rt, Ra, Rb, 24);
}

# @endif

### String Extension ###

:ffb Rt, Ra, Rb is OpSz=0 & Opc=0b100001 & Rt & Ra & Rb & Sub7=0b0001110 & StandbyZ=0 {}
:ffbi Rt, Ra, Imm8_7 is OpSz=0 & Opc=0b100001 & Rt & Ra & Imm8_7 & Sub7=0b1001110 {}
:ffmism Rt, Ra, Rb is OpSz=0 & Opc=0b100001 & Rt & Ra & Rb & Sub7=0b0001111 & StandbyZ=0 {}
:flmism Rt, Ra, Rb is OpSz=0 & Opc=0b100001 & Rt & Ra & Rb & Sub7=0b1001111 & StandbyZ=0 {}

############################
########### 16b ############
############################

define token instr16(16)
    opsz        = (15, 15)
    opc4        = (11, 14)
    opc5        = (10, 14)
    opc6        = (9, 14)
    opc7        = (8, 14)
    opc8        = (7, 14)
    opc10       = (5, 14)
    re2         = (5, 6)
    rr21         = (5, 9)
    ra4         = (5, 8)
    rr20         = (5, 8)
    ra5         = (0, 4)
    rb5         = (0, 4)
    rr21b        = (0, 4)
    rr19         = (6, 8)
    rr19b        = (8, 10)
    ra3         = (3, 5)
    rb3         = (0, 2)
    imm3u       = (0, 2)
    imm3ub      = (3, 5)
    imm5u       = (0, 4)
    imm5s       = (0, 4) signed
    imm6u       = (0, 5)
    imm7u       = (0, 6)
    imm8s       = (0, 7) signed
    imm10s      = (0, 9) signed
    imm4u       = (5, 8)
    xwi37_ls    = (7, 7)
    swid9       = (0, 8)
    rr21e1       = (4, 7)
    rr21e2       = (4, 7)
    ra5e1       = (0, 3)
    ra5e2       = (0, 3)
;

attach variables [rr21 ra5 rb5 rr21b] [
    r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15 r16 r17 r18 r19 r20 r21 r22 r23 r24 r25 p0 p1 fp gp lp sp
];

attach variables [ra4 rr20] [
    r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r16 r17 r18 r19
];

attach variables [rr19 ra3 rr19b rb3] [
    r0 r1 r2 r3 r4 r5 r6 r7
];

attach variables [ra5e1 rr21e1] [
    r0 r2 r4 r6 r8 r10 r12 r14 r16 r18 r20 r22 r24 p0 fp lp
];
attach variables [ra5e2 rr21e2] [
    r1 r3 r5 r7 r9 r11 r12 r15 r17 r19 r21 r23 r25 p1 gp sp
];
attach variables [re2] [
    r6 r8 r10 r14
];
### Move Instruction ###
:movi55 rr21, imm5s is opsz=1 & opc5=0b00001 & rr21 & imm5s { rr21 = imm5s; }
:mov55  rr21,   ra5 is opsz=1 & opc5=0b00000 & rr21 & ra5   { rr21 = ra5; }


### Add/Sub Instruction with Immediate ###

:addi45  rr20,      imm5u is opsz=1 & opc6=0b000110 & rr20       & imm5u { rr20 = rr20 + imm5u; }
:addi333 rr19, ra3, imm3u is opsz=1 & opc6=0b001110 & rr19 & ra3 & imm3u { rr19 = ra3 + imm3u; }
:subi45  rr20,      imm5u is opsz=1 & opc6=0b000111 & rr20       & imm5u { rr20 = rr20 - imm5u; }
:subi333 rr19, ra3, imm3u is opsz=1 & opc6=0b001111 & rr19 & ra3 & imm3u { rr19 = ra3 - imm3u; }


### Add/Sub Instruction ###

:add45   rr20,      rb5 is opsz=1 & opc6=0b000100 & rr20       & rb5 { rr20 = rr20 + rb5; }
:add333  rr19, ra3, rb3 is opsz=1 & opc6=0b001100 & rr19 & ra3 & rb3 { rr19 = ra3 + rb3; }
:sub45   rr20,      rb5 is opsz=1 & opc6=0b000101 & rr20       & rb5 { rr20 = rr20 - rb5; }
:sub333  rr19, ra3, rb3 is opsz=1 & opc6=0b001101 & rr19 & ra3 & rb3 { rr19 = ra3 - rb3; }


### Shift Instruction with Immediate ###

:srai45  rr20,      imm5u is opsz=1 & opc6=0b001000 & rr20       & imm5u { rr20 = rr20 s>> imm5u; }
:srli45  rr20,      imm5u is opsz=1 & opc6=0b001001 & rr20       & imm5u { rr20 = rr20 >> imm5u; }
:slli333 rr19, ra3, imm3u is opsz=1 & opc6=0b001010 & rr19 & ra3 & imm3u { rr19 = ra3 << imm3u; }


### Bit Field Mask Instruction with Immediate ###

:zeb33  rr19, ra3 is opsz=1 & opc6=0b001011 & rr19 & ra3 & imm3u=0b000 { local tmp = ra3; rr19 = zext(tmp:1); }
:zeh33  rr19, ra3 is opsz=1 & opc6=0b001011 & rr19 & ra3 & imm3u=0b001 { local tmp = ra3; rr19 = zext(tmp:2); }
:seb33  rr19, ra3 is opsz=1 & opc6=0b001011 & rr19 & ra3 & imm3u=0b010 { local tmp = ra3; rr19 = sext(tmp:1); }
:seh33  rr19, ra3 is opsz=1 & opc6=0b001011 & rr19 & ra3 & imm3u=0b011 { local tmp = ra3; rr19 = sext(tmp:2); }
:xlsb33 rr19, ra3 is opsz=1 & opc6=0b001011 & rr19 & ra3 & imm3u=0b100 { rr19 = ra3 & 1; }
:x11b33 rr19, ra3 is opsz=1 & opc6=0b001011 & rr19 & ra3 & imm3u=0b101 { rr19 = ra3 & 0x7ff; }


### Load / Store Instruction ###

:lwi450 rr20, [ra5] is opsz=1 & opc6=0b011010 & rr20 & ra5 { rr20 = *ra5; }

rel3w: off is imm3u [ off = imm3u << 2; ] { export *[const]:4 off; }
rel3h: off is imm3u [ off = imm3u << 1; ] { export *[const]:4 off; }
rel3b: off is imm3u [ off = imm3u << 0 ; ] { export *[const]:4 off; }
ra3_rel3w: [ra3 + rel3w] is ra3 & rel3w { addr:4 = ra3 + rel3w; export addr; }
ra3_rel3h: [ra3 + rel3h] is ra3 & rel3h { addr:4 = ra3 + rel3h; export addr; }
ra3_rel3b: [ra3 + rel3b] is ra3 & rel3b { addr:4 = ra3 + rel3b; export addr; }

:lwi333    rr19, ra3_rel3w    is opsz=1 & opc6=0b010000 & rr19 & ra3_rel3w   { rr19 = *ra3_rel3w; }
:lwi333.bi rr19, [ra3], rel3w is opsz=1 & opc6=0b010001 & rr19 & ra3 & rel3w { rr19 = *ra3; ra3 = ra3 + rel3w; }
:lhi333    rr19, ra3_rel3h    is opsz=1 & opc6=0b010010 & rr19 & ra3_rel3h   { local tmp:2 = *ra3_rel3h; rr19 = zext(tmp); }
:lbi333    rr19, ra3_rel3b    is opsz=1 & opc6=0b010011 & rr19 & ra3_rel3b   { local tmp:1 = *ra3_rel3b; rr19 = zext(tmp); }
:swi450    rr20, [ra5]        is opsz=1 & opc6=0b011011 & rr20 & ra5         { *ra5 = rr20; }
:swi333    rr19, ra3_rel3w    is opsz=1 & opc6=0b010100 & rr19 & ra3_rel3w   { *ra3_rel3w = rr19; }
:swi333.bi rr19, [ra3], rel3w is opsz=1 & opc6=0b010101 & rr19 & ra3 & rel3w { *ra3 = rr19; ra3 = ra3 + rel3w; }
:shi333    rr19, ra3_rel3h    is opsz=1 & opc6=0b010110 & rr19 & ra3_rel3h   { local tmp = rr19; *ra3_rel3h = tmp:2; }
:sbi333    rr19, ra3_rel3b    is opsz=1 & opc6=0b010111 & rr19 & ra3_rel3b   { local tmp = rr19; *ra3_rel3b = tmp:1; }


### Load/Store Instruction with Implied FP ###

rel7w: off is imm7u [ off = imm7u << 2; ] { export *[const]:4 off; }
fp_rel7w: [fp + rel7w] is fp & rel7w { addr:4 = fp + rel7w; export addr; }

:lwi37 rr19b, fp_rel7w is opsz=1 & rr19b & opc4=0b0111 & xwi37_ls=0 & fp_rel7w { rr19b = *fp_rel7w; }
:swi37 rr19b, fp_rel7w is opsz=1 & rr19b & opc4=0b0111 & xwi37_ls=1 & fp_rel7w { *fp_rel7w = rr19b; }


### Branch and Jump Instruction ###

rel8: addr is imm8s [ addr = inst_start + sext(imm8s << 1); ] { export *:4 addr; }


:beqs38 rr19b, rel8 is opsz=1 & opc4=0b1010 & rr19b & rel8 { if(r5 == rr19b) goto rel8; }
:bnes38 rr19b, rel8 is opsz=1 & opc4=0b1011 & rr19b & rel8 { if(r5 != rr19b) goto rel8; }
:beqz38 rr19b, rel8 is opsz=1 & opc4=0b1000 & rr19b & rel8 { if(rr19b == 0) goto rel8; }
:bnez38 rr19b, rel8 is opsz=1 & opc4=0b1001 & rr19b & rel8 { if(rr19b != 0) goto rel8; }

:j8    rel8 is opsz=1 & opc7=0b1010101     & rel8 { goto rel8; }
:jr5   rb5  is opsz=1 & opc10=0b1011101000 & rb5  { goto [rb5]; }
:ret5 rb5  is opsz=1 & opc10=0b1011101100 & rb5  { return [rb5]; }
:jral5 rb5  is opsz=1 & opc10=0b1011101001 & rb5  { lp = inst_next; call [rb5]; }


### Compare and Branch Instruction ###

:slti45  ra4, imm5u is opsz=1 & opc6=0b110011 & ra4 & imm5u { r15 = zext(ra4 < imm5u); }
:sltsi45 ra4, imm5u is opsz=1 & opc6=0b110010 & ra4 & imm5u { r15 = zext(ra4 s< imm5u); }
:slt45 ra4, rb5   is opsz=1 & opc6=0b110001 & ra4 & rb5   { r15 = zext(ra4 < rb5); }
:slts45  ra4, rb5   is opsz=1 & opc6=0b110000 & ra4 & rb5   { r15 = zext(ra4 s< rb5); }

:beqzs8 rel8 is opsz=1 & opc7=0b1101000 & rel8 { if(r15 == 0) goto rel8; }
:bnezs8 rel8 is opsz=1 & opc7=0b1101001 & rel8 { if(r15 != 0) goto rel8; }


### Misc Instruction ###

:break16 swid9 is opsz=1 & opc6=0b110101 & swid9 { break(swid9:4); }
:ex9.it imm5u is opsz=1 & opc10=0b1011101010 & imm5u {}
:ex9.it imm9u is opsz=1 & opc6=0b110101 & imm4u>0 & imm5u [ imm9u = imm4u * 32 + imm5u; ] {}
:nop16 is opsz=1 & opc6=0b001001 & rr20=0b0000 & imm5u=0b00000 { }


### ALU Instructions (V2) ###

#@if defined(BASELINE_V2)

:addi10.sp imm10s is opsz=1 & opc5=0b11011 & imm10s { sp = sp + imm10s; }


### Load/Store Instruction (V2) ###

sp_rel7w: [+ rel7w] is rel7w { addr:4 = sp + rel7w; export addr; }

:lwi37.sp rr19b, sp_rel7w is opsz=1 & rr19b & opc4=0b1110 & xwi37_ls=0 & sp_rel7w { rr19b = *sp_rel7w; }
:swi37.sp rr19b, sp_rel7w is opsz=1 & rr19b & opc4=0b1110 & xwi37_ls=1 & sp_rel7w { *sp_rel7w = rr19b; }

#@endif



### 16-bit Baseline V3 instructions ###

#@if defined(BASELINE_V3)

### ALU Instructions (V3 16-bit) ###

imm6u_: imm8 is imm6u [ imm8 = imm6u << 2; ] { export *[const]:4 imm8; }
:addri36.sp rr19, imm6u_ is opsz=1 & opc6=0b011000 & rr19 & imm6u_ { rr19 = sp + imm6u_; }
:add5.pc rr21b is opsz=1 & opc10=0b1011101101 & rr21b { rr21b = pc + rr21b; }
:and33 rr19, ra3 is opsz=1 & opc6=0b111111 & rr19 & ra3 & imm3u=0b110 { rr19 = rr19 & ra3; }
:neg33 rr19, ra3 is opsz=1 & opc6=0b111111 & rr19 & ra3 & imm3u=0b010 { rr19 = -ra3; }
:not33 rr19, ra3 is opsz=1 & opc6=0b111111 & rr19 & ra3 & imm3u=0b011 { rr19 = ~ra3; }
:or33  rr19, ra3 is opsz=1 & opc6=0b111111 & rr19 & ra3 & imm3u=0b111 { rr19 = rr19 | ra3; }
:xor33 rr19, ra3 is opsz=1 & opc6=0b111111 & rr19 & ra3 & imm3u=0b101 { rr19 = rr19 ^ ra3; }

### Bit Manipulation Instructions (V3 16-bit) ###

:bmski33 rr19, imm3ub is opsz=1 & opc6=0b001011 & rr19 & imm3ub & imm3u=0b110 { rr19 = (rr19 >> imm3ub) & 1; }
:fexti33 rr19, imm3ub is opsz=1 & opc6=0b001011 & rr19 & imm3ub & imm3u=0b111 { rr19 = rr19 & ((1 << (imm3ub + 1)) - 1); }

### Misc. Instructions (V3 16-bit) ###

imm7n: off is imm5u [ off = -((32 - imm5u) << 2); ] { export *[const]:4 off; }
:lwi45.fe rr20, [imm7n] is opsz=1 & opc6=0b011001 & rr20 & imm7n { addr:4 = r8 + imm7n; rr20 = *addr; }

:movd44 rr21e1, ra5e1 is opsz=1 & opc7=0b1111101 & rr21e1 & rr21e2 & ra5e1 & ra5e2 { rr21e1 = ra5e1; rr21e2 = ra5e2; }

imm5u_: imm6 is imm5u [ imm6 = imm5u + 16; ] { export *[const]:4 imm6; }
:movpi45 rr20, imm5u_ is opsz=1 & opc6=0b111101 & rr20 & imm5u_ { rr20 = imm5u_; }
:mul33  rr19, ra3 is opsz=1 & opc6=0b111111 & rr19 & ra3 & imm3u=0b100 { rr19 = rr19 * ra3; }

# Note: POP25 and PUSH25 are highly untested ! And they just look messy :/
imm5u__: imm8 is imm5u [ imm8 = imm5u << 3; ] { export *[const]:4 imm8; }

push25_re: re2 is re2 & re2=0 { }
push25_re: re2 is re2 & re2=1 { }
push25_re: re2 is re2 & re2=2 { }
push25_re: re2 is re2 & re2=3 { }

:push25 push25_re, imm5u__ is opsz=1 & opc8=0b11111000 & re2 & push25_re & imm5u__ {
}

pop25_re: re2 is re2 & re2=0 { }
pop25_re: re2 is re2 & re2=1 { }
pop25_re: re2 is re2 & re2=2 { }
pop25_re: re2 is re2 & re2=3 { }

:pop25 pop25_re, imm5u__ is opsz=1 & opc8=0b11111001 & re2 & pop25_re & imm5u__ {
}


#@endif

############ Floating-point ############

#@if defined(FPU)

define register offset=0x114 size=8 [
    fd0 fd1 fd2 fd3 fd4 fd5 fd6 fd7 fd8 fd9 fd10 fd11 fd12 fd13 fd14 fd15
    fd16 fd17 fd18 fd19 fd20 fd21 fd22 fd23 fd34 fd25 fd26 fd27 fd28 fd29 fd30 fd31
];

define register offset=0x114 size=4 [
    fs0 fs1 fs2 fs3 fs4 fs5 fs6 fs7 fs8 fs9 fs10 fs11 fs12 fs13 fs14 fs15
    fs16 fs17 fs18 fs19 fs20 fs21 fs22 fs23 fs34 fs25 fs26 fs27 fs28 fs29 fs30 fs31
];

define register offset=0x200 size=4 [
    fcsr fcfg    
];

define token fpu(32)
    FOpSz       = (31, 31)
    COP         = (25, 30)
    FDt         = (20, 24)
    FSt         = (20, 24)
    FRt         = (20, 24)
    FSa         = (15, 19)
    FSb         = (10, 14)
    FRa         = (15, 19)
    FDa         = (15, 19)
    FDb         = (10, 14)
    FCSR        = (10, 14)
    FCFG        = (10, 14)

    Imm12u      = (0, 11)
    Imm12s      = (0, 11) signed

    bi          = (12, 12)

    FUI2D       = (10, 14)
    FOP         = (6, 9)
    FXR         = (6, 9)
    CP0         = (4, 5)
    MxCP        = (0, 3)
    FD1         = (0, 3)
    FS1         = (0, 3)
;

attach variables [FRt FRa] [
    r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r12 r14 r15 r16 r17 r18 r19 r20 r21 r22 r23 r24 r25 p0 p1 fp gp lp sp
];

attach variables [FDt FDa FDb] [
    fd0 fd1 fd2 fd3 fd4 fd5 fd6 fd7 fd8 fd9 fd10 fd11 fd12 fd13 fd14 fd15
    fd16 fd17 fd18 fd19 fd20 fd21 fd22 fd23 fd34 fd25 fd26 fd27 fd28 fd29 fd30 fd31
];

attach variables [FSt FSa FSb] [
    fs0 fs1 fs2 fs3 fs4 fs5 fs6 fs7 fs8 fs9 fs10 fs11 fs12 fs13 fs14 fs15
    fs16 fs17 fs18 fs19 fs20 fs21 fs22 fs23 fs34 fs25 fs26 fs27 fs28 fs29 fs30 fs31
];

### Load / Store Instruction (immediate) ###

FloatWordOffset: off is Imm12s [ off = Imm12s << 2; ] { export *[const]:4 off; }

AddrFloatWordRaImm12s: [FRa + FloatWordOffset] is FRa & FloatWordOffset { addr:4 = FRa + FloatWordOffset; export addr; }

:fsdi  FDt, AddrFloatWordRaImm12s is FOpSz=0 & COP=0b011011 & FDt & bi=0 & AddrFloatWordRaImm12s { *AddrFloatWordRaImm12s = FDt; }
:fssi  FSt, AddrFloatWordRaImm12s is FOpSz=0 & COP=0b011001 & FSt & bi=0 & AddrFloatWordRaImm12s { *AddrFloatWordRaImm12s = FSt; }
:fldi  FDt, AddrFloatWordRaImm12s is FOpSz=0 & COP=0b011010 & FDt & bi=0 & AddrFloatWordRaImm12s { FDt = *AddrFloatWordRaImm12s; }
:flsi  FSt, AddrFloatWordRaImm12s is FOpSz=0 & COP=0b011000 & FSt & bi=0 & AddrFloatWordRaImm12s { FSt = *AddrFloatWordRaImm12s; }

### Load / Store Instruction (immediate, postincr) ###

:fsdi.bi  FDt, [FRa], FloatWordOffset is FOpSz=0 & COP=0b011011 & FDt & bi=1 & FRa & FloatWordOffset { *FRa = FDt; FRa = FRa + FloatWordOffset; }
:fssi.bi  FSt, [FRa], FloatWordOffset is FOpSz=0 & COP=0b011001 & FSt & bi=1 & FRa & FloatWordOffset { *FRa = FSt; FRa = FRa + FloatWordOffset; }
:fldi.bi  FDt, [FRa], FloatWordOffset is FOpSz=0 & COP=0b011010 & FDt & bi=1 & FRa & FloatWordOffset { FDt = *FRa; FRa = FRa + FloatWordOffset; }
:flsi.bi  FSt, [FRa], FloatWordOffset is FOpSz=0 & COP=0b011000 & FSt & bi=1 & FRa & FloatWordOffset { FSt = *FRa; FRa = FRa + FloatWordOffset; }

### Move Instruction ###

:fmfcfg FRt is FOpSz=0 & COP=0b110101 & FCFG=0 & FXR=0b1100 & MxCP=0b0001 & CP0=0 & FRt { FRt = fcfg; }
:fmfcsr FRt is FOpSz=0 & COP=0b110101 & FCSR=1 & FXR=0b1100 & CP0=0 & MxCP=0b0001 { FRt = fcsr; }
:fmfsr FRt, FSa is FOpSz=0 & COP=0b110101 & FRt & FSa & FXR=0 & CP0=0 & MxCP=0b0001 { FRt = FSa; }
:fmtcsr FRt is FOpSz=0 & COP=0b110101 & FCSR=0b00001 & FXR=0b1100 & CP0=0 & MxCP=0b1001 & FRt { fcsr = FRt; } 
:fmtsr FRt, FSa is FOpSz=0 & COP=0b110101 & FXR=0 & FRt & FSa & MxCP=0b1001 { FSa = FRt; } 

### Conversion ### 

:fui2d FDt, FSa is FOpSz=0 & COP=0b110101 & FDt & FSa & FUI2D=0b01000 & FOP=0b1111 & FD1=0b1000 { FDt = int2float(FSa); }

### Arithmetic ###

:fmuld FDt, FDa, FDb is FOpSz=0 & COP=0b110101 & FDt & FDa & FDb & FOP=0b1100 & FD1=0b1000 { FDt = FDa * FDb; }
:faddd FDt, FDa, FDb is FOpSz=0 & COP=0b110101 & FDt & FDa & FDb & FOP=0 & FD1=0b1000 { FDt = FDa + FDb; }
:fdivd FDt, FDa, FDb is FOpSz=0 & COP=0b110101 & FDt & FDa & FDb & FOP=0b1101 & FD1=0b1000 { FDt = FDa / FDb; }
:fd2ui.z FSt, FDa is FOpSz=0 & COP=0b110101 & FSt & FDa & FUI2D=0b10100 & FOP=0b1111 & FD1=0b1000 { FSt = float2float(floor(FDa)); }

### Other ###

:fcpyss FSt, FSa, FSb is FOpSz=0 & COP=0b110101 & FSt & FSa & FSb & FOP=0b0011 & FS1=0b0000 
{ 
    FSt = (FSa & 0x7fffffff) | (FSb & 0x80000000); 
}

#@endif
