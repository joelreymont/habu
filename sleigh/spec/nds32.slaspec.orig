### General ###

define endian=big;
define alignment=2;
define space ram type=ram_space size=4 wordsize=1 default;
define space register type=register_space size=4;

define register offset=0 size=4
[r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15 r16 r17 r18 r19 r20 r21 r22 r23 r24 r25 p0 p1 fp gp lp sp];

define register offset=0x90 size=4
[pc ipc mult_addr mult_inc];

define register offset=0x100 size=8
[d0 d1];

define register offset=0x100 size=4
[d0.hi d0.lo d1.hi d1.lo itb];

define register offset=0x20 size=4
[msc_cfg];

# System registers...
# 0x179 $misc_ctl (mtsr)
# 0x89  $ivb (mtsr)
# 0x20  $msc_cfg (mfsr)
# 0x228 $fucpr (mfsr, mtsr)
# 0x8   $icm_cfg (mfsr)

define token instr32(32)
    OpSz        = (31, 31)
    Opc         = (25, 30)
    Rt          = (20, 24)
    Rth         = (21, 24)
    Rtl         = (21, 24)
    Ra          = (15, 19)
    Rb          = (10, 14)
    Rd          = (5, 9)
    Rs          = (5, 9)
    Sub5        = (0, 4)
    Sub6        = (0, 5)
    Sub8        = (0, 7)
    Imm5u       = (10, 14)
    Imm5s       = (10, 14) signed
    Br1t        = (14, 14)
    Br2t        = (16, 19)
    Alu2Mod     = (6, 9)
    Dtl         = (22, 24)
    Dt          = (21, 21)
    Dtlow       = (21, 21)
    Dthigh      = (21, 21)
    Dtr         = (20, 20)
    JIt         = (24, 24)
    Imm19s      = (0, 18) signed
    Imm18s      = (0, 17) signed
    Imm17s      = (0, 16) signed
    Imm16s      = (0, 15) signed
    Imm14s      = (0, 13) signed
    Imm15u      = (0, 14)
    Imm15s      = (0, 14) signed
    Imm20u      = (0, 19)
    Imm20s      = (0, 19) signed
    Imm24s      = (0, 23) signed
    Imm11s		= (8, 18) signed
    Imm8s		= (0, 7) signed
    sv          = (8, 9)
    SrIdx       = (10, 19)
    Swid        = (5, 19)

    CctlZ       = (11, 14)
    CctlLevel   = (10, 10)
    CctlSub     = (5, 9)

    MsyncZ      = (8, 19)
    MsyncSub    = (5, 7)

    DtIt        = (8, 9)
    Jz          = (6, 7)
    JrHint      = (5, 5)

    ToggleL     = (21, 24)
    Toggle      = (20, 20)

    Usr         = (15, 19)
    Group       = (10, 14)

    DprefD      = (24, 24)
    DprefSub    = (20, 23)

    TlbopSub    = (5, 9)

    StandbyZ    = (7, 9)
    StandbySub  = (5, 6)

    GpSub1      = (19, 19)
    GpSub2      = (18, 19)
    GpSub3      = (17, 19)

    sh          = (5, 9)

    Bxxc		= (19, 19)

    LsmwRa = (15, 19)
    LsmwRb = (20, 24)
    LsmwRb_ = (20, 24)
    LsmwRe = (10, 14)
    LsmwRe_ = (10, 14)
    Enable4 = (6, 9)
    Enable4_fp = (9, 9)
    Enable4_gp = (8, 8)
    Enable4_lp = (7, 7)
    Enable4_sp = (6, 6)
    LsmwLs = (5, 5)
    LsmwBa = (4, 4)
    LsmwId = (3, 3)
    LsmwM = (2, 2)
    LsmwSub = (0, 1)
;

attach variables [Rt Rs Ra Rb Rd LsmwRa LsmwRb LsmwRe] [
    r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15 r16 r17 r18 r19 r20 r21 r22 r23 r24 r25 p0 p1 fp gp lp sp
];

attach variables [Rtl] [
    r0 r2 r4 r6 r8 r10 r12 r14 r16 r18 r20 r22 r24 p0 fp lp
];

attach variables [Rth] [
    r1 r3 r5 r7 r9 r11 r13 r15 r17 r19 r21 r23 r25 p1 gp sp
];

attach variables [Dt] [
    d0 d1
];

attach variables [Dtlow] [
    d0.lo d1.lo
];

attach variables [Dthigh] [
    d0.hi d1.hi
];

# attach variables [SrIdx] [
#     msc_cfg
# ];

### ALU Instruction with Immediate ###

:addi  Rt, Ra, Imm15s is OpSz=0 & Opc=0b101000 & Rt & Ra & Imm15s { Rt = Ra + Imm15s; }
:subri Rt, Ra, Imm15s is OpSz=0 & Opc=0b101001 & Rt & Ra & Imm15s { Rt = Imm15s - Ra; }
:andi  Rt, Ra, Imm15u is OpSz=0 & Opc=0b101010 & Rt & Ra & Imm15u { Rt = Ra & Imm15u; }
:ori   Rt, Ra, Imm15u is OpSz=0 & Opc=0b101100 & Rt & Ra & Imm15u { Rt = Ra | Imm15u; }
:xori  Rt, Ra, Imm15u is OpSz=0 & Opc=0b101011 & Rt & Ra & Imm15u { Rt = Ra ^ Imm15u; }
:slti  Rt, Ra, Imm15s is OpSz=0 & Opc=0b101110 & Rt & Ra & Imm15s { Rt = zext(Ra < Imm15s); }
:sltsi Rt, Ra, Imm15s is OpSz=0 & Opc=0b101111 & Rt & Ra & Imm15s { Rt = zext(Ra s< Imm15s); }
:movi  Rt,     Imm20s is OpSz=0 & Opc=0b100010 & Rt & Imm20s      { Rt = Imm20s; }
:sethi Rt,     Imm20u is OpSz=0 & Opc=0b100011 & Rt & Imm20u      { Rt = Imm20u << 12;}


### ALU Instruction ###

:add  Rt, Ra, Rb is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rd=0 & Sub5=0b00000 { Rt = Ra + Rb; }
:sub  Rt, Ra, Rb is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rd=0 & Sub5=0b00001 { Rt = Ra - Rb; }
:and  Rt, Ra, Rb is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rd=0 & Sub5=0b00010 { Rt = Ra & Rb; }
:xor  Rt, Ra, Rb is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rd=0 & Sub5=0b00011 { Rt = Ra ^ Rb; }
:or   Rt, Ra, Rb is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rd=0 & Sub5=0b00100 { Rt = Ra | Rb; }
:nor  Rt, Ra, Rb is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rd=0 & Sub5=0b00101 { Rt = ~(Ra | Rb); }
:slt  Rt, Ra, Rb is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rd=0 & Sub5=0b00110 { Rt = zext(Ra < Rb); }
:slts Rt, Ra, Rb is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rd=0 & Sub5=0b00111 { Rt = zext(Ra s< Rb); }
:sva  Rt, Ra, Rb is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rd=0 & Sub5=0b11000 { Rt = zext(scarry(Ra, Rb)); }
:svs  Rt, Ra, Rb is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rd=0 & Sub5=0b11001 { Rt = zext(sborrow(Ra, Rb)); }
:seb  Rt, Ra     is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb=0b00000 & Rd=0 & Sub5=0b10000 { local tmp = Ra; Rt = sext(tmp:1); }
:seh  Rt, Ra     is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb=0b00000 & Rd=0 & Sub5=0b10001 { local tmp = Ra; Rt = sext(tmp:2); }
:zeb  Rt, Ra     is OpSz=0 & Opc=0b101010 & Rt & Ra & Imm15u=0xff                  { local tmp = Ra; Rt = zext(tmp:1); }
:zeh  Rt, Ra     is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb=0b00000 & Rd=0 & Sub5=0b10011 { local tmp = Ra; Rt = zext(tmp:2); }
:wsbh Rt, Ra     is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb=0b00000 & Rd=0 & Sub5=0b10100
{
    Rt = ((Ra & 0x000000ff) << 8)
       | ((Ra & 0x0000ff00) >> 8)
       | ((Ra & 0x00ff0000) << 8)
       | ((Ra & 0xff000000) >> 8);
}


### Shifter Instruction ###

:slli  Rt, Ra, Imm5u is OpSz=0 & Opc=0b100000 & Rt & Ra & Imm5u & Rd=0 & Sub5=0b01000 { Rt = Ra  << Imm5u; }
:srli  Rt, Ra, Imm5u is OpSz=0 & Opc=0b100000 & Rt & Ra & Imm5u & Rd=0 & Sub5=0b01001 { Rt = Ra  >> Imm5u; }
:srai  Rt, Ra, Imm5u is OpSz=0 & Opc=0b100000 & Rt & Ra & Imm5u & Rd=0 & Sub5=0b01010 { Rt = Ra s>> Imm5u; }
:rotri Rt, Ra, Imm5u is OpSz=0 & Opc=0b100000 & Rt & Ra & Imm5u & Rd=0 & Sub5=0b01011 { Rt = (Ra >> Imm5u) | (Ra << (32 - Imm5u)); }
:sll   Rt, Ra, Rb    is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb    & Rd=0 & Sub5=0b01100 { tmp:4 = Rb & 0b11111; Rt = Ra  << tmp; }
:srl   Rt, Ra, Rb    is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb    & Rd=0 & Sub5=0b01101 { tmp:4 = Rb & 0b11111; Rt = Ra  >> tmp; }
:sra   Rt, Ra, Rb    is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb    & Rd=0 & Sub5=0b01110 { tmp:4 = Rb & 0b11111; Rt = Ra s>> tmp; }
:rotr  Rt, Ra, Rb    is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb    & Rd=0 & Sub5=0b01111 { tmp:4 = Rb & 0b11111; Rt = (Ra >> tmp) | (Ra << (32 - tmp)); }


### Multiply Instruction ###

:mul     Rt,    Ra, Rb is OpSz=0 & Opc=0b100001 & Rt                    & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b100100 { Rt = Ra * Rb; }
:mults64 Dt,    Ra, Rb is OpSz=0 & Opc=0b100001 & Dtl=0 & Dt    & Dtr=0 & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b101000 { Dt = sext(Ra) * sext(Rb); }
:mulr224  Dt,    Ra, Rb is OpSz=0 & Opc=0b100001 & Dtl=0 & Dt    & Dtr=0 & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b101001 { Dt = zext(Ra) * zext(Rb); }
:madds64 Dt,    Ra, Rb is OpSz=0 & Opc=0b100001 & Dtl=0 & Dt    & Dtr=0 & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b101010 { Dt = Dt + (sext(Ra) * sext(Rb)); }
:madd64  Dt,    Ra, Rb is OpSz=0 & Opc=0b100001 & Dtl=0 & Dt    & Dtr=0 & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b101011 { Dt = Dt + (zext(Ra) * zext(Rb)); }
:msubs64 Dt,    Ra, Rb is OpSz=0 & Opc=0b100001 & Dtl=0 & Dt    & Dtr=0 & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b101100 { Dt = Dt - (sext(Ra) * sext(Rb)); }
:msub64  Dt,    Ra, Rb is OpSz=0 & Opc=0b100001 & Dtl=0 & Dt    & Dtr=0 & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b101101 { Dt = Dt - (zext(Ra) * zext(Rb)); }
:mulr192  Dtlow, Ra, Rb is OpSz=0 & Opc=0b100001 & Dtl=0 & Dtlow & Dtr=0 & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b110001 { Dtlow = Ra * Rb; }
:madd32  Dtlow, Ra, Rb is OpSz=0 & Opc=0b100001 & Dtl=0 & Dtlow & Dtr=0 & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b110011 { Dtlow = Dtlow + (Ra * Rb); }
:msub32  Dtlow, Ra, Rb is OpSz=0 & Opc=0b100001 & Dtl=0 & Dtlow & Dtr=0 & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b110101 { Dtlow = Dtlow - (Ra * Rb); }


# TODO : special instruction, but used get the division results
# There are more special registers
UsrName: d0.lo is Group=0 & Usr=0 & d0.lo { export d0.lo; }
UsrName: d0.hi is Group=0 & Usr=1 & d0.hi { export d0.hi; }
UsrName: d1.lo is Group=0 & Usr=2 & d1.lo { export d1.lo; }
UsrName: d1.hi is Group=0 & Usr=3 & d1.hi { export d1.hi; }
UsrName: itb is Group=0 & Usr=0b11100 & itb { export itb; }

:mtusr Rt, UsrName is OpSz=0 & Opc=0b100001 & Rt & UsrName & Alu2Mod=0b0000 & Sub6=0b100001 { UsrName = Rt; }
:mfusr Rt, UsrName is OpSz=0 & Opc=0b100001 & Rt & UsrName & Alu2Mod=0b0000 & Sub6=0b100000 { Rt = UsrName; }


### Divide Instructions ###

:div  Dt, Ra, Rb is OpSz=0 & Opc=0b100001 & Dtl=0 & Dt & Dtlow & Dthigh & Dtr=0 & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b101111 { Dtlow = Ra  / Rb; Dthigh = Ra  % Rb; }
:divs Dt, Ra, Rb is OpSz=0 & Opc=0b100001 & Dtl=0 & Dt & Dtlow & Dthigh & Dtr=0 & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b101110 { Dtlow = Ra s/ Rb; Dthigh = Ra s% Rb; }


### Load / Store Instruction (immediate) ###

ByteOffset: off is Imm15s [ off = Imm15s << 0; ] { export *[const]:4 off; }
HalfOffset: off is Imm15s [ off = Imm15s << 1; ] { export *[const]:4 off; }
WordOffset: off is Imm15s [ off = Imm15s << 2; ] { export *[const]:4 off; }

AddrByteRaImm15s: [Ra + ByteOffset] is Ra & ByteOffset { addr:4 = Ra + ByteOffset; export addr; }
AddrHalfRaImm15s: [Ra + HalfOffset] is Ra & HalfOffset { addr:4 = Ra + HalfOffset; export addr; }
AddrWordRaImm15s: [Ra + WordOffset] is Ra & WordOffset { addr:4 = Ra + WordOffset; export addr; }

:lwi  Rt, AddrWordRaImm15s is OpSz=0 & Opc=0b000010 & Rt & AddrWordRaImm15s { Rt = *AddrWordRaImm15s; }
:lhi  Rt, AddrHalfRaImm15s is OpSz=0 & Opc=0b000001 & Rt & AddrHalfRaImm15s { local tmp:2 = *AddrHalfRaImm15s; Rt = zext(tmp); }
:lhsi Rt, AddrHalfRaImm15s is OpSz=0 & Opc=0b010001 & Rt & AddrHalfRaImm15s { local tmp:2 = *AddrHalfRaImm15s; Rt = sext(tmp); }
:lbi  Rt, AddrByteRaImm15s is OpSz=0 & Opc=0b000000 & Rt & AddrByteRaImm15s { local tmp:1 = *AddrByteRaImm15s; Rt = zext(tmp); }
:lbsi Rt, AddrByteRaImm15s is OpSz=0 & Opc=0b010000 & Rt & AddrByteRaImm15s { local tmp:1 = *AddrByteRaImm15s; Rt = sext(tmp); }
:swi  Rt, AddrWordRaImm15s is OpSz=0 & Opc=0b001010 & Rt & AddrWordRaImm15s { *AddrWordRaImm15s = Rt; }

:shi  Rt, AddrHalfRaImm15s is OpSz=0 & Opc=0b001001 & Rt & AddrHalfRaImm15s { local tmp = Rt; *AddrHalfRaImm15s = tmp:2; }
:sbi  Rt, AddrByteRaImm15s is OpSz=0 & Opc=0b001000 & Rt & AddrByteRaImm15s { local tmp = Rt; *AddrByteRaImm15s = tmp:1; }

### Load / Store Instruction (immediate, postincr) ###

:lwi.bi  Rt, [Ra], WordOffset is OpSz=0 & Opc=0b000110 & Rt & Ra & WordOffset { Rt = *Ra; Ra = Ra + WordOffset; }
:lhi.bi  Rt, [Ra], HalfOffset is OpSz=0 & Opc=0b000101 & Rt & Ra & HalfOffset { local tmp:2 = *Ra; Rt = zext(tmp); Ra = Ra + HalfOffset; }
:lhsi.bi Rt, [Ra], HalfOffset is OpSz=0 & Opc=0b010101 & Rt & Ra & HalfOffset { local tmp:2 = *Ra; Rt = sext(tmp); Ra = Ra + HalfOffset; }
:lbi.bi  Rt, [Ra], ByteOffset is OpSz=0 & Opc=0b000100 & Rt & Ra & ByteOffset { local tmp:1 = *Ra; Rt = zext(tmp); Ra = Ra + ByteOffset; }
:lbsi.bi Rt, [Ra], ByteOffset is OpSz=0 & Opc=0b010100 & Rt & Ra & ByteOffset { local tmp:1 = *Ra; Rt = sext(tmp); Ra = Ra + ByteOffset; }
:swi.bi  Rt, [Ra], WordOffset is OpSz=0 & Opc=0b001110 & Rt & Ra & WordOffset { *Ra = Rt; Ra = Ra + WordOffset; }
:shi.bi  Rt, [Ra], HalfOffset is OpSz=0 & Opc=0b001101 & Rt & Ra & HalfOffset { local tmp = Rt; *Ra = tmp:2; Ra = Ra + HalfOffset; }
:sbi.bi  Rt, [Ra], ByteOffset is OpSz=0 & Opc=0b001100 & Rt & Ra & ByteOffset { local tmp = Rt; *Ra = tmp:1; Ra = Ra + ByteOffset; }


### Load / Store Instruction (register) ###

OffsetRbsv: (Rb "<<" sv) is Rb & sv { off:4 = Rb << sv; export off; }
AddrRaRbsv: [Ra + OffsetRbsv] is Ra & OffsetRbsv { addr:4 = Ra + OffsetRbsv; export addr; }

:lw  Rt, AddrRaRbsv is OpSz=0 & Opc=0b011100 & Rt & AddrRaRbsv & Sub8=0b00000010 { Rt = *AddrRaRbsv; }
:lh  Rt, AddrRaRbsv is OpSz=0 & Opc=0b011100 & Rt & AddrRaRbsv & Sub8=0b00000001 { local tmp:2 = *AddrRaRbsv; Rt = zext(tmp); }
:lhs Rt, AddrRaRbsv is OpSz=0 & Opc=0b011100 & Rt & AddrRaRbsv & Sub8=0b00010001 { local tmp:2 = *AddrRaRbsv; Rt = sext(tmp); }
:lb  Rt, AddrRaRbsv is OpSz=0 & Opc=0b011100 & Rt & AddrRaRbsv & Sub8=0b00000000 { local tmp:1 = *AddrRaRbsv; Rt = zext(tmp); }
:lbs Rt, AddrRaRbsv is OpSz=0 & Opc=0b011100 & Rt & AddrRaRbsv & Sub8=0b00010000 { local tmp:1 = *AddrRaRbsv; Rt = sext(tmp); }
:sw  Rt, AddrRaRbsv is OpSz=0 & Opc=0b011100 & Rt & AddrRaRbsv & Sub8=0b00001010 { *AddrRaRbsv = Rt; }
:sh  Rt, AddrRaRbsv is OpSz=0 & Opc=0b011100 & Rt & AddrRaRbsv & Sub8=0b00001001 { local tmp = Rt; *AddrRaRbsv = tmp:2; }
:sb  Rt, AddrRaRbsv is OpSz=0 & Opc=0b011100 & Rt & AddrRaRbsv & Sub8=0b00001000 { local tmp = Rt; *AddrRaRbsv = tmp:1; }


### Load / Store Instruction (register, postincr) ###

:lw.bi  Rt, [Ra], OffsetRbsv is OpSz=0 & Opc=0b011100 & Rt & Ra & OffsetRbsv & Sub8=0b00000110 { Rt = *Ra; Ra = Ra + OffsetRbsv; }
:lh.bi  Rt, [Ra], OffsetRbsv is OpSz=0 & Opc=0b011100 & Rt & Ra & OffsetRbsv & Sub8=0b00000101 { local tmp:2 = *Ra; Rt = zext(tmp); Ra = Ra + OffsetRbsv; }
:lhs.bi Rt, [Ra], OffsetRbsv is OpSz=0 & Opc=0b011100 & Rt & Ra & OffsetRbsv & Sub8=0b00010101 { local tmp:2 = *Ra; Rt = sext(tmp); Ra = Ra + OffsetRbsv; }
:lb.bi  Rt, [Ra], OffsetRbsv is OpSz=0 & Opc=0b011100 & Rt & Ra & OffsetRbsv & Sub8=0b00000100 { local tmp:1 = *Ra; Rt = zext(tmp); Ra = Ra + OffsetRbsv; }
:lbs.bi Rt, [Ra], OffsetRbsv is OpSz=0 & Opc=0b011100 & Rt & Ra & OffsetRbsv & Sub8=0b00010100 { local tmp:1 = *Ra; Rt = sext(tmp); Ra = Ra + OffsetRbsv; }
:sw.bi  Rt, [Ra], OffsetRbsv is OpSz=0 & Opc=0b011100 & Rt & Ra & OffsetRbsv & Sub8=0b00001110 { *Ra = Rt; Ra = Ra + OffsetRbsv; }
:sh.bi  Rt, [Ra], OffsetRbsv is OpSz=0 & Opc=0b011100 & Rt & Ra & OffsetRbsv & Sub8=0b00001101 { local tmp = Rt; *Ra = tmp:2; Ra = Ra + OffsetRbsv; }
:sb.bi  Rt, [Ra], OffsetRbsv is OpSz=0 & Opc=0b011100 & Rt & Ra & OffsetRbsv & Sub8=0b00001100 { local tmp = Rt; *Ra = tmp:1; Ra = Ra + OffsetRbsv; }


### Load / Store Multiple Word Instruction ###

# TODO : this is ugly
# @include "lsmw.sinc"

macro Lmwbi(reg) {
    reg = *mult_addr;
    mult_addr = mult_addr + 4;
}

macro Lmwbd(reg) {
    reg = *mult_addr;
    mult_addr = mult_addr - 4;
}

macro Lmwai(reg) {
    mult_addr = mult_addr + 4;
    reg = *mult_addr;
}

macro Lmwad(reg) {
    mult_addr = mult_addr - 4;
    reg = *mult_addr;
}

macro Smwbi(reg) {
    *mult_addr = reg;
    mult_addr = mult_addr + 4;
}

macro Smwbd(reg) {
    *mult_addr = reg;
    mult_addr = mult_addr - 4;
}

macro Smwai(reg) {
    mult_addr = mult_addr + 4;
    *mult_addr = reg;
}

macro Smwad(reg) {
    mult_addr = mult_addr - 4;
    *mult_addr = reg;
}

Lmwbi.r0: r0 is LsmwRb_<=0 & LsmwRe_>=0 & r0 { Lmwbi(r0); }
Lmwbi.r0: is LsmwRb_ & LsmwRe_ { }
Lmwbi.r1: r1 is LsmwRb_<=1 & LsmwRe_>=1 & r1 { Lmwbi(r1); }
Lmwbi.r1: is LsmwRb_ & LsmwRe_ { }
Lmwbi.r2: r2 is LsmwRb_<=2 & LsmwRe_>=2 & r2 { Lmwbi(r2); }
Lmwbi.r2: is LsmwRb_ & LsmwRe_ { }
Lmwbi.r3: r3 is LsmwRb_<=3 & LsmwRe_>=3 & r3 { Lmwbi(r3); }
Lmwbi.r3: is LsmwRb_ & LsmwRe_ { }
Lmwbi.r4: r4 is LsmwRb_<=4 & LsmwRe_>=4 & r4 { Lmwbi(r4); }
Lmwbi.r4: is LsmwRb_ & LsmwRe_ { }
Lmwbi.r5: r5 is LsmwRb_<=5 & LsmwRe_>=5 & r5 { Lmwbi(r5); }
Lmwbi.r5: is LsmwRb_ & LsmwRe_ { }
Lmwbi.r6: r6 is LsmwRb_<=6 & LsmwRe_>=6 & r6 { Lmwbi(r6); }
Lmwbi.r6: is LsmwRb_ & LsmwRe_ { }
Lmwbi.r7: r7 is LsmwRb_<=7 & LsmwRe_>=7 & r7 { Lmwbi(r7); }
Lmwbi.r7: is LsmwRb_ & LsmwRe_ { }
Lmwbi.r8: r8 is LsmwRb_<=8 & LsmwRe_>=8 & r8 { Lmwbi(r8); }
Lmwbi.r8: is LsmwRb_ & LsmwRe_ { }
Lmwbi.r9: r9 is LsmwRb_<=9 & LsmwRe_>=9 & r9 { Lmwbi(r9); }
Lmwbi.r9: is LsmwRb_ & LsmwRe_ { }
Lmwbi.r10: r10 is LsmwRb_<=10 & LsmwRe_>=10 & r10 { Lmwbi(r10); }
Lmwbi.r10: is LsmwRb_ & LsmwRe_ { }
Lmwbi.r11: r11 is LsmwRb_<=11 & LsmwRe_>=11 & r11 { Lmwbi(r11); }
Lmwbi.r11: is LsmwRb_ & LsmwRe_ { }
Lmwbi.r12: r12 is LsmwRb_<=12 & LsmwRe_>=12 & r12 { Lmwbi(r12); }
Lmwbi.r12: is LsmwRb_ & LsmwRe_ { }
Lmwbi.r12: r12 is LsmwRb_<=13 & LsmwRe_>=13 & r12 { Lmwbi(r12); }
Lmwbi.r12: is LsmwRb_ & LsmwRe_ { }
Lmwbi.r14: r14 is LsmwRb_<=14 & LsmwRe_>=14 & r14 { Lmwbi(r14); }
Lmwbi.r14: is LsmwRb_ & LsmwRe_ { }
Lmwbi.r15: r15 is LsmwRb_<=15 & LsmwRe_>=15 & r15 { Lmwbi(r15); }
Lmwbi.r15: is LsmwRb_ & LsmwRe_ { }
Lmwbi.r16: r16 is LsmwRb_<=16 & LsmwRe_>=16 & r16 { Lmwbi(r16); }
Lmwbi.r16: is LsmwRb_ & LsmwRe_ { }
Lmwbi.r17: r17 is LsmwRb_<=17 & LsmwRe_>=17 & r17 { Lmwbi(r17); }
Lmwbi.r17: is LsmwRb_ & LsmwRe_ { }
Lmwbi.r18: r18 is LsmwRb_<=18 & LsmwRe_>=18 & r18 { Lmwbi(r18); }
Lmwbi.r18: is LsmwRb_ & LsmwRe_ { }
Lmwbi.r19: r19 is LsmwRb_<=19 & LsmwRe_>=19 & r19 { Lmwbi(r19); }
Lmwbi.r19: is LsmwRb_ & LsmwRe_ { }
Lmwbi.r20: r20 is LsmwRb_<=20 & LsmwRe_>=20 & r20 { Lmwbi(r20); }
Lmwbi.r20: is LsmwRb_ & LsmwRe_ { }
Lmwbi.r21: r21 is LsmwRb_<=21 & LsmwRe_>=21 & r21 { Lmwbi(r21); }
Lmwbi.r21: is LsmwRb_ & LsmwRe_ { }
Lmwbi.r22: r22 is LsmwRb_<=22 & LsmwRe_>=22 & r22 { Lmwbi(r22); }
Lmwbi.r22: is LsmwRb_ & LsmwRe_ { }
Lmwbi.r23: r23 is LsmwRb_<=23 & LsmwRe_>=23 & r23 { Lmwbi(r23); }
Lmwbi.r23: is LsmwRb_ & LsmwRe_ { }
Lmwbi.r24: r24 is LsmwRb_<=24 & LsmwRe_>=24 & r24 { Lmwbi(r24); }
Lmwbi.r24: is LsmwRb_ & LsmwRe_ { }
Lmwbi.r25: r25 is LsmwRb_<=25 & LsmwRe_>=25 & r25 { Lmwbi(r25); }
Lmwbi.r25: is LsmwRb_ & LsmwRe_ { }
Lmwbi.p0: p0 is LsmwRb_<=26 & LsmwRe_>=26 & p0 { Lmwbi(p0); }
Lmwbi.p0: is LsmwRb_ & LsmwRe_ { }
Lmwbi.p1: p1 is LsmwRb_<=27 & LsmwRe_>=27 & p1 { Lmwbi(p1); }
Lmwbi.p1: is LsmwRb_ & LsmwRe_ { }
Lmwbi.fp: fp is Enable4_fp=1 & fp { Lmwbi(fp); }
Lmwbi.fp: is Enable4_fp=0 { }
Lmwbi.gp: gp is Enable4_gp=1 & gp { Lmwbi(gp); }
Lmwbi.gp: is Enable4_gp=0 { }
Lmwbi.lp: lp is Enable4_lp=1 & lp { Lmwbi(lp); }
Lmwbi.lp: is Enable4_lp=0 { }
Lmwbi.sp: sp is Enable4_sp=1 & sp { Lmwbi(sp); }
Lmwbi.sp: is Enable4_sp=0 { }

Lmwbd.r0: r0 is LsmwRb_<=0 & LsmwRe_>=0 & r0 { Lmwbd(r0); }
Lmwbd.r0: is LsmwRb_ & LsmwRe_ { }
Lmwbd.r1: r1 is LsmwRb_<=1 & LsmwRe_>=1 & r1 { Lmwbd(r1); }
Lmwbd.r1: is LsmwRb_ & LsmwRe_ { }
Lmwbd.r2: r2 is LsmwRb_<=2 & LsmwRe_>=2 & r2 { Lmwbd(r2); }
Lmwbd.r2: is LsmwRb_ & LsmwRe_ { }
Lmwbd.r3: r3 is LsmwRb_<=3 & LsmwRe_>=3 & r3 { Lmwbd(r3); }
Lmwbd.r3: is LsmwRb_ & LsmwRe_ { }
Lmwbd.r4: r4 is LsmwRb_<=4 & LsmwRe_>=4 & r4 { Lmwbd(r4); }
Lmwbd.r4: is LsmwRb_ & LsmwRe_ { }
Lmwbd.r5: r5 is LsmwRb_<=5 & LsmwRe_>=5 & r5 { Lmwbd(r5); }
Lmwbd.r5: is LsmwRb_ & LsmwRe_ { }
Lmwbd.r6: r6 is LsmwRb_<=6 & LsmwRe_>=6 & r6 { Lmwbd(r6); }
Lmwbd.r6: is LsmwRb_ & LsmwRe_ { }
Lmwbd.r7: r7 is LsmwRb_<=7 & LsmwRe_>=7 & r7 { Lmwbd(r7); }
Lmwbd.r7: is LsmwRb_ & LsmwRe_ { }
Lmwbd.r8: r8 is LsmwRb_<=8 & LsmwRe_>=8 & r8 { Lmwbd(r8); }
Lmwbd.r8: is LsmwRb_ & LsmwRe_ { }
Lmwbd.r9: r9 is LsmwRb_<=9 & LsmwRe_>=9 & r9 { Lmwbd(r9); }
Lmwbd.r9: is LsmwRb_ & LsmwRe_ { }
Lmwbd.r10: r10 is LsmwRb_<=10 & LsmwRe_>=10 & r10 { Lmwbd(r10); }
Lmwbd.r10: is LsmwRb_ & LsmwRe_ { }
Lmwbd.r11: r11 is LsmwRb_<=11 & LsmwRe_>=11 & r11 { Lmwbd(r11); }
Lmwbd.r11: is LsmwRb_ & LsmwRe_ { }
Lmwbd.r12: r12 is LsmwRb_<=12 & LsmwRe_>=12 & r12 { Lmwbd(r12); }
Lmwbd.r12: is LsmwRb_ & LsmwRe_ { }
Lmwbd.r12: r12 is LsmwRb_<=13 & LsmwRe_>=13 & r12 { Lmwbd(r12); }
Lmwbd.r12: is LsmwRb_ & LsmwRe_ { }
Lmwbd.r14: r14 is LsmwRb_<=14 & LsmwRe_>=14 & r14 { Lmwbd(r14); }
Lmwbd.r14: is LsmwRb_ & LsmwRe_ { }
Lmwbd.r15: r15 is LsmwRb_<=15 & LsmwRe_>=15 & r15 { Lmwbd(r15); }
Lmwbd.r15: is LsmwRb_ & LsmwRe_ { }
Lmwbd.r16: r16 is LsmwRb_<=16 & LsmwRe_>=16 & r16 { Lmwbd(r16); }
Lmwbd.r16: is LsmwRb_ & LsmwRe_ { }
Lmwbd.r17: r17 is LsmwRb_<=17 & LsmwRe_>=17 & r17 { Lmwbd(r17); }
Lmwbd.r17: is LsmwRb_ & LsmwRe_ { }
Lmwbd.r18: r18 is LsmwRb_<=18 & LsmwRe_>=18 & r18 { Lmwbd(r18); }
Lmwbd.r18: is LsmwRb_ & LsmwRe_ { }
Lmwbd.r19: r19 is LsmwRb_<=19 & LsmwRe_>=19 & r19 { Lmwbd(r19); }
Lmwbd.r19: is LsmwRb_ & LsmwRe_ { }
Lmwbd.r20: r20 is LsmwRb_<=20 & LsmwRe_>=20 & r20 { Lmwbd(r20); }
Lmwbd.r20: is LsmwRb_ & LsmwRe_ { }
Lmwbd.r21: r21 is LsmwRb_<=21 & LsmwRe_>=21 & r21 { Lmwbd(r21); }
Lmwbd.r21: is LsmwRb_ & LsmwRe_ { }
Lmwbd.r22: r22 is LsmwRb_<=22 & LsmwRe_>=22 & r22 { Lmwbd(r22); }
Lmwbd.r22: is LsmwRb_ & LsmwRe_ { }
Lmwbd.r23: r23 is LsmwRb_<=23 & LsmwRe_>=23 & r23 { Lmwbd(r23); }
Lmwbd.r23: is LsmwRb_ & LsmwRe_ { }
Lmwbd.r24: r24 is LsmwRb_<=24 & LsmwRe_>=24 & r24 { Lmwbd(r24); }
Lmwbd.r24: is LsmwRb_ & LsmwRe_ { }
Lmwbd.r25: r25 is LsmwRb_<=25 & LsmwRe_>=25 & r25 { Lmwbd(r25); }
Lmwbd.r25: is LsmwRb_ & LsmwRe_ { }
Lmwbd.p0: p0 is LsmwRb_<=26 & LsmwRe_>=26 & p0 { Lmwbd(p0); }
Lmwbd.p0: is LsmwRb_ & LsmwRe_ { }
Lmwbd.p1: p1 is LsmwRb_<=27 & LsmwRe_>=27 & p1 { Lmwbd(p1); }
Lmwbd.p1: is LsmwRb_ & LsmwRe_ { }
Lmwbd.fp: fp is Enable4_fp=1 & fp { Lmwbd(fp); }
Lmwbd.fp: is Enable4_fp=0 { }
Lmwbd.gp: gp is Enable4_gp=1 & gp { Lmwbd(gp); }
Lmwbd.gp: is Enable4_gp=0 { }
Lmwbd.lp: lp is Enable4_lp=1 & lp { Lmwbd(lp); }
Lmwbd.lp: is Enable4_lp=0 { }
Lmwbd.sp: sp is Enable4_sp=1 & sp { Lmwbd(sp); }
Lmwbd.sp: is Enable4_sp=0 { }

Lmwai.r0: r0 is LsmwRb_<=0 & LsmwRe_>=0 & r0 { Lmwai(r0); }
Lmwai.r0: is LsmwRb_ & LsmwRe_ { }
Lmwai.r1: r1 is LsmwRb_<=1 & LsmwRe_>=1 & r1 { Lmwai(r1); }
Lmwai.r1: is LsmwRb_ & LsmwRe_ { }
Lmwai.r2: r2 is LsmwRb_<=2 & LsmwRe_>=2 & r2 { Lmwai(r2); }
Lmwai.r2: is LsmwRb_ & LsmwRe_ { }
Lmwai.r3: r3 is LsmwRb_<=3 & LsmwRe_>=3 & r3 { Lmwai(r3); }
Lmwai.r3: is LsmwRb_ & LsmwRe_ { }
Lmwai.r4: r4 is LsmwRb_<=4 & LsmwRe_>=4 & r4 { Lmwai(r4); }
Lmwai.r4: is LsmwRb_ & LsmwRe_ { }
Lmwai.r5: r5 is LsmwRb_<=5 & LsmwRe_>=5 & r5 { Lmwai(r5); }
Lmwai.r5: is LsmwRb_ & LsmwRe_ { }
Lmwai.r6: r6 is LsmwRb_<=6 & LsmwRe_>=6 & r6 { Lmwai(r6); }
Lmwai.r6: is LsmwRb_ & LsmwRe_ { }
Lmwai.r7: r7 is LsmwRb_<=7 & LsmwRe_>=7 & r7 { Lmwai(r7); }
Lmwai.r7: is LsmwRb_ & LsmwRe_ { }
Lmwai.r8: r8 is LsmwRb_<=8 & LsmwRe_>=8 & r8 { Lmwai(r8); }
Lmwai.r8: is LsmwRb_ & LsmwRe_ { }
Lmwai.r9: r9 is LsmwRb_<=9 & LsmwRe_>=9 & r9 { Lmwai(r9); }
Lmwai.r9: is LsmwRb_ & LsmwRe_ { }
Lmwai.r10: r10 is LsmwRb_<=10 & LsmwRe_>=10 & r10 { Lmwai(r10); }
Lmwai.r10: is LsmwRb_ & LsmwRe_ { }
Lmwai.r11: r11 is LsmwRb_<=11 & LsmwRe_>=11 & r11 { Lmwai(r11); }
Lmwai.r11: is LsmwRb_ & LsmwRe_ { }
Lmwai.r12: r12 is LsmwRb_<=12 & LsmwRe_>=12 & r12 { Lmwai(r12); }
Lmwai.r12: is LsmwRb_ & LsmwRe_ { }
Lmwai.r12: r12 is LsmwRb_<=13 & LsmwRe_>=13 & r12 { Lmwai(r12); }
Lmwai.r12: is LsmwRb_ & LsmwRe_ { }
Lmwai.r14: r14 is LsmwRb_<=14 & LsmwRe_>=14 & r14 { Lmwai(r14); }
Lmwai.r14: is LsmwRb_ & LsmwRe_ { }
Lmwai.r15: r15 is LsmwRb_<=15 & LsmwRe_>=15 & r15 { Lmwai(r15); }
Lmwai.r15: is LsmwRb_ & LsmwRe_ { }
Lmwai.r16: r16 is LsmwRb_<=16 & LsmwRe_>=16 & r16 { Lmwai(r16); }
Lmwai.r16: is LsmwRb_ & LsmwRe_ { }
Lmwai.r17: r17 is LsmwRb_<=17 & LsmwRe_>=17 & r17 { Lmwai(r17); }
Lmwai.r17: is LsmwRb_ & LsmwRe_ { }
Lmwai.r18: r18 is LsmwRb_<=18 & LsmwRe_>=18 & r18 { Lmwai(r18); }
Lmwai.r18: is LsmwRb_ & LsmwRe_ { }
Lmwai.r19: r19 is LsmwRb_<=19 & LsmwRe_>=19 & r19 { Lmwai(r19); }
Lmwai.r19: is LsmwRb_ & LsmwRe_ { }
Lmwai.r20: r20 is LsmwRb_<=20 & LsmwRe_>=20 & r20 { Lmwai(r20); }
Lmwai.r20: is LsmwRb_ & LsmwRe_ { }
Lmwai.r21: r21 is LsmwRb_<=21 & LsmwRe_>=21 & r21 { Lmwai(r21); }
Lmwai.r21: is LsmwRb_ & LsmwRe_ { }
Lmwai.r22: r22 is LsmwRb_<=22 & LsmwRe_>=22 & r22 { Lmwai(r22); }
Lmwai.r22: is LsmwRb_ & LsmwRe_ { }
Lmwai.r23: r23 is LsmwRb_<=23 & LsmwRe_>=23 & r23 { Lmwai(r23); }
Lmwai.r23: is LsmwRb_ & LsmwRe_ { }
Lmwai.r24: r24 is LsmwRb_<=24 & LsmwRe_>=24 & r24 { Lmwai(r24); }
Lmwai.r24: is LsmwRb_ & LsmwRe_ { }
Lmwai.r25: r25 is LsmwRb_<=25 & LsmwRe_>=25 & r25 { Lmwai(r25); }
Lmwai.r25: is LsmwRb_ & LsmwRe_ { }
Lmwai.p0: p0 is LsmwRb_<=26 & LsmwRe_>=26 & p0 { Lmwai(p0); }
Lmwai.p0: is LsmwRb_ & LsmwRe_ { }
Lmwai.p1: p1 is LsmwRb_<=27 & LsmwRe_>=27 & p1 { Lmwai(p1); }
Lmwai.p1: is LsmwRb_ & LsmwRe_ { }
Lmwai.fp: fp is Enable4_fp=1 & fp { Lmwai(fp); }
Lmwai.fp: is Enable4_fp=0 { }
Lmwai.gp: gp is Enable4_gp=1 & gp { Lmwai(gp); }
Lmwai.gp: is Enable4_gp=0 { }
Lmwai.lp: lp is Enable4_lp=1 & lp { Lmwai(lp); }
Lmwai.lp: is Enable4_lp=0 { }
Lmwai.sp: sp is Enable4_sp=1 & sp { Lmwai(sp); }
Lmwai.sp: is Enable4_sp=0 { }

Lmwad.r0: r0 is LsmwRb_<=0 & LsmwRe_>=0 & r0 { Lmwad(r0); }
Lmwad.r0: is LsmwRb_ & LsmwRe_ { }
Lmwad.r1: r1 is LsmwRb_<=1 & LsmwRe_>=1 & r1 { Lmwad(r1); }
Lmwad.r1: is LsmwRb_ & LsmwRe_ { }
Lmwad.r2: r2 is LsmwRb_<=2 & LsmwRe_>=2 & r2 { Lmwad(r2); }
Lmwad.r2: is LsmwRb_ & LsmwRe_ { }
Lmwad.r3: r3 is LsmwRb_<=3 & LsmwRe_>=3 & r3 { Lmwad(r3); }
Lmwad.r3: is LsmwRb_ & LsmwRe_ { }
Lmwad.r4: r4 is LsmwRb_<=4 & LsmwRe_>=4 & r4 { Lmwad(r4); }
Lmwad.r4: is LsmwRb_ & LsmwRe_ { }
Lmwad.r5: r5 is LsmwRb_<=5 & LsmwRe_>=5 & r5 { Lmwad(r5); }
Lmwad.r5: is LsmwRb_ & LsmwRe_ { }
Lmwad.r6: r6 is LsmwRb_<=6 & LsmwRe_>=6 & r6 { Lmwad(r6); }
Lmwad.r6: is LsmwRb_ & LsmwRe_ { }
Lmwad.r7: r7 is LsmwRb_<=7 & LsmwRe_>=7 & r7 { Lmwad(r7); }
Lmwad.r7: is LsmwRb_ & LsmwRe_ { }
Lmwad.r8: r8 is LsmwRb_<=8 & LsmwRe_>=8 & r8 { Lmwad(r8); }
Lmwad.r8: is LsmwRb_ & LsmwRe_ { }
Lmwad.r9: r9 is LsmwRb_<=9 & LsmwRe_>=9 & r9 { Lmwad(r9); }
Lmwad.r9: is LsmwRb_ & LsmwRe_ { }
Lmwad.r10: r10 is LsmwRb_<=10 & LsmwRe_>=10 & r10 { Lmwad(r10); }
Lmwad.r10: is LsmwRb_ & LsmwRe_ { }
Lmwad.r11: r11 is LsmwRb_<=11 & LsmwRe_>=11 & r11 { Lmwad(r11); }
Lmwad.r11: is LsmwRb_ & LsmwRe_ { }
Lmwad.r12: r12 is LsmwRb_<=12 & LsmwRe_>=12 & r12 { Lmwad(r12); }
Lmwad.r12: is LsmwRb_ & LsmwRe_ { }
Lmwad.r12: r12 is LsmwRb_<=13 & LsmwRe_>=13 & r12 { Lmwad(r12); }
Lmwad.r12: is LsmwRb_ & LsmwRe_ { }
Lmwad.r14: r14 is LsmwRb_<=14 & LsmwRe_>=14 & r14 { Lmwad(r14); }
Lmwad.r14: is LsmwRb_ & LsmwRe_ { }
Lmwad.r15: r15 is LsmwRb_<=15 & LsmwRe_>=15 & r15 { Lmwad(r15); }
Lmwad.r15: is LsmwRb_ & LsmwRe_ { }
Lmwad.r16: r16 is LsmwRb_<=16 & LsmwRe_>=16 & r16 { Lmwad(r16); }
Lmwad.r16: is LsmwRb_ & LsmwRe_ { }
Lmwad.r17: r17 is LsmwRb_<=17 & LsmwRe_>=17 & r17 { Lmwad(r17); }
Lmwad.r17: is LsmwRb_ & LsmwRe_ { }
Lmwad.r18: r18 is LsmwRb_<=18 & LsmwRe_>=18 & r18 { Lmwad(r18); }
Lmwad.r18: is LsmwRb_ & LsmwRe_ { }
Lmwad.r19: r19 is LsmwRb_<=19 & LsmwRe_>=19 & r19 { Lmwad(r19); }
Lmwad.r19: is LsmwRb_ & LsmwRe_ { }
Lmwad.r20: r20 is LsmwRb_<=20 & LsmwRe_>=20 & r20 { Lmwad(r20); }
Lmwad.r20: is LsmwRb_ & LsmwRe_ { }
Lmwad.r21: r21 is LsmwRb_<=21 & LsmwRe_>=21 & r21 { Lmwad(r21); }
Lmwad.r21: is LsmwRb_ & LsmwRe_ { }
Lmwad.r22: r22 is LsmwRb_<=22 & LsmwRe_>=22 & r22 { Lmwad(r22); }
Lmwad.r22: is LsmwRb_ & LsmwRe_ { }
Lmwad.r23: r23 is LsmwRb_<=23 & LsmwRe_>=23 & r23 { Lmwad(r23); }
Lmwad.r23: is LsmwRb_ & LsmwRe_ { }
Lmwad.r24: r24 is LsmwRb_<=24 & LsmwRe_>=24 & r24 { Lmwad(r24); }
Lmwad.r24: is LsmwRb_ & LsmwRe_ { }
Lmwad.r25: r25 is LsmwRb_<=25 & LsmwRe_>=25 & r25 { Lmwad(r25); }
Lmwad.r25: is LsmwRb_ & LsmwRe_ { }
Lmwad.p0: p0 is LsmwRb_<=26 & LsmwRe_>=26 & p0 { Lmwad(p0); }
Lmwad.p0: is LsmwRb_ & LsmwRe_ { }
Lmwad.p1: p1 is LsmwRb_<=27 & LsmwRe_>=27 & p1 { Lmwad(p1); }
Lmwad.p1: is LsmwRb_ & LsmwRe_ { }
Lmwad.fp: fp is Enable4_fp=1 & fp { Lmwad(fp); }
Lmwad.fp: is Enable4_fp=0 { }
Lmwad.gp: gp is Enable4_gp=1 & gp { Lmwad(gp); }
Lmwad.gp: is Enable4_gp=0 { }
Lmwad.lp: lp is Enable4_lp=1 & lp { Lmwad(lp); }
Lmwad.lp: is Enable4_lp=0 { }
Lmwad.sp: sp is Enable4_sp=1 & sp { Lmwad(sp); }
Lmwad.sp: is Enable4_sp=0 { }

Smwbi.r0: r0 is LsmwRb_<=0 & LsmwRe_>=0 & r0 { Smwbi(r0); }
Smwbi.r0: is LsmwRb_ & LsmwRe_ { }
Smwbi.r1: r1 is LsmwRb_<=1 & LsmwRe_>=1 & r1 { Smwbi(r1); }
Smwbi.r1: is LsmwRb_ & LsmwRe_ { }
Smwbi.r2: r2 is LsmwRb_<=2 & LsmwRe_>=2 & r2 { Smwbi(r2); }
Smwbi.r2: is LsmwRb_ & LsmwRe_ { }
Smwbi.r3: r3 is LsmwRb_<=3 & LsmwRe_>=3 & r3 { Smwbi(r3); }
Smwbi.r3: is LsmwRb_ & LsmwRe_ { }
Smwbi.r4: r4 is LsmwRb_<=4 & LsmwRe_>=4 & r4 { Smwbi(r4); }
Smwbi.r4: is LsmwRb_ & LsmwRe_ { }
Smwbi.r5: r5 is LsmwRb_<=5 & LsmwRe_>=5 & r5 { Smwbi(r5); }
Smwbi.r5: is LsmwRb_ & LsmwRe_ { }
Smwbi.r6: r6 is LsmwRb_<=6 & LsmwRe_>=6 & r6 { Smwbi(r6); }
Smwbi.r6: is LsmwRb_ & LsmwRe_ { }
Smwbi.r7: r7 is LsmwRb_<=7 & LsmwRe_>=7 & r7 { Smwbi(r7); }
Smwbi.r7: is LsmwRb_ & LsmwRe_ { }
Smwbi.r8: r8 is LsmwRb_<=8 & LsmwRe_>=8 & r8 { Smwbi(r8); }
Smwbi.r8: is LsmwRb_ & LsmwRe_ { }
Smwbi.r9: r9 is LsmwRb_<=9 & LsmwRe_>=9 & r9 { Smwbi(r9); }
Smwbi.r9: is LsmwRb_ & LsmwRe_ { }
Smwbi.r10: r10 is LsmwRb_<=10 & LsmwRe_>=10 & r10 { Smwbi(r10); }
Smwbi.r10: is LsmwRb_ & LsmwRe_ { }
Smwbi.r11: r11 is LsmwRb_<=11 & LsmwRe_>=11 & r11 { Smwbi(r11); }
Smwbi.r11: is LsmwRb_ & LsmwRe_ { }
Smwbi.r12: r12 is LsmwRb_<=12 & LsmwRe_>=12 & r12 { Smwbi(r12); }
Smwbi.r12: is LsmwRb_ & LsmwRe_ { }
Smwbi.r12: r12 is LsmwRb_<=13 & LsmwRe_>=13 & r12 { Smwbi(r12); }
Smwbi.r12: is LsmwRb_ & LsmwRe_ { }
Smwbi.r14: r14 is LsmwRb_<=14 & LsmwRe_>=14 & r14 { Smwbi(r14); }
Smwbi.r14: is LsmwRb_ & LsmwRe_ { }
Smwbi.r15: r15 is LsmwRb_<=15 & LsmwRe_>=15 & r15 { Smwbi(r15); }
Smwbi.r15: is LsmwRb_ & LsmwRe_ { }
Smwbi.r16: r16 is LsmwRb_<=16 & LsmwRe_>=16 & r16 { Smwbi(r16); }
Smwbi.r16: is LsmwRb_ & LsmwRe_ { }
Smwbi.r17: r17 is LsmwRb_<=17 & LsmwRe_>=17 & r17 { Smwbi(r17); }
Smwbi.r17: is LsmwRb_ & LsmwRe_ { }
Smwbi.r18: r18 is LsmwRb_<=18 & LsmwRe_>=18 & r18 { Smwbi(r18); }
Smwbi.r18: is LsmwRb_ & LsmwRe_ { }
Smwbi.r19: r19 is LsmwRb_<=19 & LsmwRe_>=19 & r19 { Smwbi(r19); }
Smwbi.r19: is LsmwRb_ & LsmwRe_ { }
Smwbi.r20: r20 is LsmwRb_<=20 & LsmwRe_>=20 & r20 { Smwbi(r20); }
Smwbi.r20: is LsmwRb_ & LsmwRe_ { }
Smwbi.r21: r21 is LsmwRb_<=21 & LsmwRe_>=21 & r21 { Smwbi(r21); }
Smwbi.r21: is LsmwRb_ & LsmwRe_ { }
Smwbi.r22: r22 is LsmwRb_<=22 & LsmwRe_>=22 & r22 { Smwbi(r22); }
Smwbi.r22: is LsmwRb_ & LsmwRe_ { }
Smwbi.r23: r23 is LsmwRb_<=23 & LsmwRe_>=23 & r23 { Smwbi(r23); }
Smwbi.r23: is LsmwRb_ & LsmwRe_ { }
Smwbi.r24: r24 is LsmwRb_<=24 & LsmwRe_>=24 & r24 { Smwbi(r24); }
Smwbi.r24: is LsmwRb_ & LsmwRe_ { }
Smwbi.r25: r25 is LsmwRb_<=25 & LsmwRe_>=25 & r25 { Smwbi(r25); }
Smwbi.r25: is LsmwRb_ & LsmwRe_ { }
Smwbi.p0: p0 is LsmwRb_<=26 & LsmwRe_>=26 & p0 { Smwbi(p0); }
Smwbi.p0: is LsmwRb_ & LsmwRe_ { }
Smwbi.p1: p1 is LsmwRb_<=27 & LsmwRe_>=27 & p1 { Smwbi(p1); }
Smwbi.p1: is LsmwRb_ & LsmwRe_ { }
Smwbi.fp: fp is Enable4_fp=1 & fp { Smwbi(fp); }
Smwbi.fp: is Enable4_fp=0 { }
Smwbi.gp: gp is Enable4_gp=1 & gp { Smwbi(gp); }
Smwbi.gp: is Enable4_gp=0 { }
Smwbi.lp: lp is Enable4_lp=1 & lp { Smwbi(lp); }
Smwbi.lp: is Enable4_lp=0 { }
Smwbi.sp: sp is Enable4_sp=1 & sp { Smwbi(sp); }
Smwbi.sp: is Enable4_sp=0 { }

Smwbd.r0: r0 is LsmwRb_<=0 & LsmwRe_>=0 & r0 { Smwbd(r0); }
Smwbd.r0: is LsmwRb_ & LsmwRe_ { }
Smwbd.r1: r1 is LsmwRb_<=1 & LsmwRe_>=1 & r1 { Smwbd(r1); }
Smwbd.r1: is LsmwRb_ & LsmwRe_ { }
Smwbd.r2: r2 is LsmwRb_<=2 & LsmwRe_>=2 & r2 { Smwbd(r2); }
Smwbd.r2: is LsmwRb_ & LsmwRe_ { }
Smwbd.r3: r3 is LsmwRb_<=3 & LsmwRe_>=3 & r3 { Smwbd(r3); }
Smwbd.r3: is LsmwRb_ & LsmwRe_ { }
Smwbd.r4: r4 is LsmwRb_<=4 & LsmwRe_>=4 & r4 { Smwbd(r4); }
Smwbd.r4: is LsmwRb_ & LsmwRe_ { }
Smwbd.r5: r5 is LsmwRb_<=5 & LsmwRe_>=5 & r5 { Smwbd(r5); }
Smwbd.r5: is LsmwRb_ & LsmwRe_ { }
Smwbd.r6: r6 is LsmwRb_<=6 & LsmwRe_>=6 & r6 { Smwbd(r6); }
Smwbd.r6: is LsmwRb_ & LsmwRe_ { }
Smwbd.r7: r7 is LsmwRb_<=7 & LsmwRe_>=7 & r7 { Smwbd(r7); }
Smwbd.r7: is LsmwRb_ & LsmwRe_ { }
Smwbd.r8: r8 is LsmwRb_<=8 & LsmwRe_>=8 & r8 { Smwbd(r8); }
Smwbd.r8: is LsmwRb_ & LsmwRe_ { }
Smwbd.r9: r9 is LsmwRb_<=9 & LsmwRe_>=9 & r9 { Smwbd(r9); }
Smwbd.r9: is LsmwRb_ & LsmwRe_ { }
Smwbd.r10: r10 is LsmwRb_<=10 & LsmwRe_>=10 & r10 { Smwbd(r10); }
Smwbd.r10: is LsmwRb_ & LsmwRe_ { }
Smwbd.r11: r11 is LsmwRb_<=11 & LsmwRe_>=11 & r11 { Smwbd(r11); }
Smwbd.r11: is LsmwRb_ & LsmwRe_ { }
Smwbd.r12: r12 is LsmwRb_<=12 & LsmwRe_>=12 & r12 { Smwbd(r12); }
Smwbd.r12: is LsmwRb_ & LsmwRe_ { }
Smwbd.r12: r12 is LsmwRb_<=13 & LsmwRe_>=13 & r12 { Smwbd(r12); }
Smwbd.r12: is LsmwRb_ & LsmwRe_ { }
Smwbd.r14: r14 is LsmwRb_<=14 & LsmwRe_>=14 & r14 { Smwbd(r14); }
Smwbd.r14: is LsmwRb_ & LsmwRe_ { }
Smwbd.r15: r15 is LsmwRb_<=15 & LsmwRe_>=15 & r15 { Smwbd(r15); }
Smwbd.r15: is LsmwRb_ & LsmwRe_ { }
Smwbd.r16: r16 is LsmwRb_<=16 & LsmwRe_>=16 & r16 { Smwbd(r16); }
Smwbd.r16: is LsmwRb_ & LsmwRe_ { }
Smwbd.r17: r17 is LsmwRb_<=17 & LsmwRe_>=17 & r17 { Smwbd(r17); }
Smwbd.r17: is LsmwRb_ & LsmwRe_ { }
Smwbd.r18: r18 is LsmwRb_<=18 & LsmwRe_>=18 & r18 { Smwbd(r18); }
Smwbd.r18: is LsmwRb_ & LsmwRe_ { }
Smwbd.r19: r19 is LsmwRb_<=19 & LsmwRe_>=19 & r19 { Smwbd(r19); }
Smwbd.r19: is LsmwRb_ & LsmwRe_ { }
Smwbd.r20: r20 is LsmwRb_<=20 & LsmwRe_>=20 & r20 { Smwbd(r20); }
Smwbd.r20: is LsmwRb_ & LsmwRe_ { }
Smwbd.r21: r21 is LsmwRb_<=21 & LsmwRe_>=21 & r21 { Smwbd(r21); }
Smwbd.r21: is LsmwRb_ & LsmwRe_ { }
Smwbd.r22: r22 is LsmwRb_<=22 & LsmwRe_>=22 & r22 { Smwbd(r22); }
Smwbd.r22: is LsmwRb_ & LsmwRe_ { }
Smwbd.r23: r23 is LsmwRb_<=23 & LsmwRe_>=23 & r23 { Smwbd(r23); }
Smwbd.r23: is LsmwRb_ & LsmwRe_ { }
Smwbd.r24: r24 is LsmwRb_<=24 & LsmwRe_>=24 & r24 { Smwbd(r24); }
Smwbd.r24: is LsmwRb_ & LsmwRe_ { }
Smwbd.r25: r25 is LsmwRb_<=25 & LsmwRe_>=25 & r25 { Smwbd(r25); }
Smwbd.r25: is LsmwRb_ & LsmwRe_ { }
Smwbd.p0: p0 is LsmwRb_<=26 & LsmwRe_>=26 & p0 { Smwbd(p0); }
Smwbd.p0: is LsmwRb_ & LsmwRe_ { }
Smwbd.p1: p1 is LsmwRb_<=27 & LsmwRe_>=27 & p1 { Smwbd(p1); }
Smwbd.p1: is LsmwRb_ & LsmwRe_ { }
Smwbd.fp: fp is Enable4_fp=1 & fp { Smwbd(fp); }
Smwbd.fp: is Enable4_fp=0 { }
Smwbd.gp: gp is Enable4_gp=1 & gp { Smwbd(gp); }
Smwbd.gp: is Enable4_gp=0 { }
Smwbd.lp: lp is Enable4_lp=1 & lp { Smwbd(lp); }
Smwbd.lp: is Enable4_lp=0 { }
Smwbd.sp: sp is Enable4_sp=1 & sp { Smwbd(sp); }
Smwbd.sp: is Enable4_sp=0 { }

Smwai.r0: r0 is LsmwRb_<=0 & LsmwRe_>=0 & r0 { Smwai(r0); }
Smwai.r0: is LsmwRb_ & LsmwRe_ { }
Smwai.r1: r1 is LsmwRb_<=1 & LsmwRe_>=1 & r1 { Smwai(r1); }
Smwai.r1: is LsmwRb_ & LsmwRe_ { }
Smwai.r2: r2 is LsmwRb_<=2 & LsmwRe_>=2 & r2 { Smwai(r2); }
Smwai.r2: is LsmwRb_ & LsmwRe_ { }
Smwai.r3: r3 is LsmwRb_<=3 & LsmwRe_>=3 & r3 { Smwai(r3); }
Smwai.r3: is LsmwRb_ & LsmwRe_ { }
Smwai.r4: r4 is LsmwRb_<=4 & LsmwRe_>=4 & r4 { Smwai(r4); }
Smwai.r4: is LsmwRb_ & LsmwRe_ { }
Smwai.r5: r5 is LsmwRb_<=5 & LsmwRe_>=5 & r5 { Smwai(r5); }
Smwai.r5: is LsmwRb_ & LsmwRe_ { }
Smwai.r6: r6 is LsmwRb_<=6 & LsmwRe_>=6 & r6 { Smwai(r6); }
Smwai.r6: is LsmwRb_ & LsmwRe_ { }
Smwai.r7: r7 is LsmwRb_<=7 & LsmwRe_>=7 & r7 { Smwai(r7); }
Smwai.r7: is LsmwRb_ & LsmwRe_ { }
Smwai.r8: r8 is LsmwRb_<=8 & LsmwRe_>=8 & r8 { Smwai(r8); }
Smwai.r8: is LsmwRb_ & LsmwRe_ { }
Smwai.r9: r9 is LsmwRb_<=9 & LsmwRe_>=9 & r9 { Smwai(r9); }
Smwai.r9: is LsmwRb_ & LsmwRe_ { }
Smwai.r10: r10 is LsmwRb_<=10 & LsmwRe_>=10 & r10 { Smwai(r10); }
Smwai.r10: is LsmwRb_ & LsmwRe_ { }
Smwai.r11: r11 is LsmwRb_<=11 & LsmwRe_>=11 & r11 { Smwai(r11); }
Smwai.r11: is LsmwRb_ & LsmwRe_ { }
Smwai.r12: r12 is LsmwRb_<=12 & LsmwRe_>=12 & r12 { Smwai(r12); }
Smwai.r12: is LsmwRb_ & LsmwRe_ { }
Smwai.r12: r12 is LsmwRb_<=13 & LsmwRe_>=13 & r12 { Smwai(r12); }
Smwai.r12: is LsmwRb_ & LsmwRe_ { }
Smwai.r14: r14 is LsmwRb_<=14 & LsmwRe_>=14 & r14 { Smwai(r14); }
Smwai.r14: is LsmwRb_ & LsmwRe_ { }
Smwai.r15: r15 is LsmwRb_<=15 & LsmwRe_>=15 & r15 { Smwai(r15); }
Smwai.r15: is LsmwRb_ & LsmwRe_ { }
Smwai.r16: r16 is LsmwRb_<=16 & LsmwRe_>=16 & r16 { Smwai(r16); }
Smwai.r16: is LsmwRb_ & LsmwRe_ { }
Smwai.r17: r17 is LsmwRb_<=17 & LsmwRe_>=17 & r17 { Smwai(r17); }
Smwai.r17: is LsmwRb_ & LsmwRe_ { }
Smwai.r18: r18 is LsmwRb_<=18 & LsmwRe_>=18 & r18 { Smwai(r18); }
Smwai.r18: is LsmwRb_ & LsmwRe_ { }
Smwai.r19: r19 is LsmwRb_<=19 & LsmwRe_>=19 & r19 { Smwai(r19); }
Smwai.r19: is LsmwRb_ & LsmwRe_ { }
Smwai.r20: r20 is LsmwRb_<=20 & LsmwRe_>=20 & r20 { Smwai(r20); }
Smwai.r20: is LsmwRb_ & LsmwRe_ { }
Smwai.r21: r21 is LsmwRb_<=21 & LsmwRe_>=21 & r21 { Smwai(r21); }
Smwai.r21: is LsmwRb_ & LsmwRe_ { }
Smwai.r22: r22 is LsmwRb_<=22 & LsmwRe_>=22 & r22 { Smwai(r22); }
Smwai.r22: is LsmwRb_ & LsmwRe_ { }
Smwai.r23: r23 is LsmwRb_<=23 & LsmwRe_>=23 & r23 { Smwai(r23); }
Smwai.r23: is LsmwRb_ & LsmwRe_ { }
Smwai.r24: r24 is LsmwRb_<=24 & LsmwRe_>=24 & r24 { Smwai(r24); }
Smwai.r24: is LsmwRb_ & LsmwRe_ { }
Smwai.r25: r25 is LsmwRb_<=25 & LsmwRe_>=25 & r25 { Smwai(r25); }
Smwai.r25: is LsmwRb_ & LsmwRe_ { }
Smwai.p0: p0 is LsmwRb_<=26 & LsmwRe_>=26 & p0 { Smwai(p0); }
Smwai.p0: is LsmwRb_ & LsmwRe_ { }
Smwai.p1: p1 is LsmwRb_<=27 & LsmwRe_>=27 & p1 { Smwai(p1); }
Smwai.p1: is LsmwRb_ & LsmwRe_ { }
Smwai.fp: fp is Enable4_fp=1 & fp { Smwai(fp); }
Smwai.fp: is Enable4_fp=0 { }
Smwai.gp: gp is Enable4_gp=1 & gp { Smwai(gp); }
Smwai.gp: is Enable4_gp=0 { }
Smwai.lp: lp is Enable4_lp=1 & lp { Smwai(lp); }
Smwai.lp: is Enable4_lp=0 { }
Smwai.sp: sp is Enable4_sp=1 & sp { Smwai(sp); }
Smwai.sp: is Enable4_sp=0 { }

Smwad.r0: r0 is LsmwRb_<=0 & LsmwRe_>=0 & r0 { Smwad(r0); }
Smwad.r0: is LsmwRb_ & LsmwRe_ { }
Smwad.r1: r1 is LsmwRb_<=1 & LsmwRe_>=1 & r1 { Smwad(r1); }
Smwad.r1: is LsmwRb_ & LsmwRe_ { }
Smwad.r2: r2 is LsmwRb_<=2 & LsmwRe_>=2 & r2 { Smwad(r2); }
Smwad.r2: is LsmwRb_ & LsmwRe_ { }
Smwad.r3: r3 is LsmwRb_<=3 & LsmwRe_>=3 & r3 { Smwad(r3); }
Smwad.r3: is LsmwRb_ & LsmwRe_ { }
Smwad.r4: r4 is LsmwRb_<=4 & LsmwRe_>=4 & r4 { Smwad(r4); }
Smwad.r4: is LsmwRb_ & LsmwRe_ { }
Smwad.r5: r5 is LsmwRb_<=5 & LsmwRe_>=5 & r5 { Smwad(r5); }
Smwad.r5: is LsmwRb_ & LsmwRe_ { }
Smwad.r6: r6 is LsmwRb_<=6 & LsmwRe_>=6 & r6 { Smwad(r6); }
Smwad.r6: is LsmwRb_ & LsmwRe_ { }
Smwad.r7: r7 is LsmwRb_<=7 & LsmwRe_>=7 & r7 { Smwad(r7); }
Smwad.r7: is LsmwRb_ & LsmwRe_ { }
Smwad.r8: r8 is LsmwRb_<=8 & LsmwRe_>=8 & r8 { Smwad(r8); }
Smwad.r8: is LsmwRb_ & LsmwRe_ { }
Smwad.r9: r9 is LsmwRb_<=9 & LsmwRe_>=9 & r9 { Smwad(r9); }
Smwad.r9: is LsmwRb_ & LsmwRe_ { }
Smwad.r10: r10 is LsmwRb_<=10 & LsmwRe_>=10 & r10 { Smwad(r10); }
Smwad.r10: is LsmwRb_ & LsmwRe_ { }
Smwad.r11: r11 is LsmwRb_<=11 & LsmwRe_>=11 & r11 { Smwad(r11); }
Smwad.r11: is LsmwRb_ & LsmwRe_ { }
Smwad.r12: r12 is LsmwRb_<=12 & LsmwRe_>=12 & r12 { Smwad(r12); }
Smwad.r12: is LsmwRb_ & LsmwRe_ { }
Smwad.r12: r12 is LsmwRb_<=13 & LsmwRe_>=13 & r12 { Smwad(r12); }
Smwad.r12: is LsmwRb_ & LsmwRe_ { }
Smwad.r14: r14 is LsmwRb_<=14 & LsmwRe_>=14 & r14 { Smwad(r14); }
Smwad.r14: is LsmwRb_ & LsmwRe_ { }
Smwad.r15: r15 is LsmwRb_<=15 & LsmwRe_>=15 & r15 { Smwad(r15); }
Smwad.r15: is LsmwRb_ & LsmwRe_ { }
Smwad.r16: r16 is LsmwRb_<=16 & LsmwRe_>=16 & r16 { Smwad(r16); }
Smwad.r16: is LsmwRb_ & LsmwRe_ { }
Smwad.r17: r17 is LsmwRb_<=17 & LsmwRe_>=17 & r17 { Smwad(r17); }
Smwad.r17: is LsmwRb_ & LsmwRe_ { }
Smwad.r18: r18 is LsmwRb_<=18 & LsmwRe_>=18 & r18 { Smwad(r18); }
Smwad.r18: is LsmwRb_ & LsmwRe_ { }
Smwad.r19: r19 is LsmwRb_<=19 & LsmwRe_>=19 & r19 { Smwad(r19); }
Smwad.r19: is LsmwRb_ & LsmwRe_ { }
Smwad.r20: r20 is LsmwRb_<=20 & LsmwRe_>=20 & r20 { Smwad(r20); }
Smwad.r20: is LsmwRb_ & LsmwRe_ { }
Smwad.r21: r21 is LsmwRb_<=21 & LsmwRe_>=21 & r21 { Smwad(r21); }
Smwad.r21: is LsmwRb_ & LsmwRe_ { }
Smwad.r22: r22 is LsmwRb_<=22 & LsmwRe_>=22 & r22 { Smwad(r22); }
Smwad.r22: is LsmwRb_ & LsmwRe_ { }
Smwad.r23: r23 is LsmwRb_<=23 & LsmwRe_>=23 & r23 { Smwad(r23); }
Smwad.r23: is LsmwRb_ & LsmwRe_ { }
Smwad.r24: r24 is LsmwRb_<=24 & LsmwRe_>=24 & r24 { Smwad(r24); }
Smwad.r24: is LsmwRb_ & LsmwRe_ { }
Smwad.r25: r25 is LsmwRb_<=25 & LsmwRe_>=25 & r25 { Smwad(r25); }
Smwad.r25: is LsmwRb_ & LsmwRe_ { }
Smwad.p0: p0 is LsmwRb_<=26 & LsmwRe_>=26 & p0 { Smwad(p0); }
Smwad.p0: is LsmwRb_ & LsmwRe_ { }
Smwad.p1: p1 is LsmwRb_<=27 & LsmwRe_>=27 & p1 { Smwad(p1); }
Smwad.p1: is LsmwRb_ & LsmwRe_ { }
Smwad.fp: fp is Enable4_fp=1 & fp { Smwad(fp); }
Smwad.fp: is Enable4_fp=0 { }
Smwad.gp: gp is Enable4_gp=1 & gp { Smwad(gp); }
Smwad.gp: is Enable4_gp=0 { }
Smwad.lp: lp is Enable4_lp=1 & lp { Smwad(lp); }
Smwad.lp: is Enable4_lp=0 { }
Smwad.sp: sp is Enable4_sp=1 & sp { Smwad(sp); }
Smwad.sp: is Enable4_sp=0 { }

Lmw.regs: is LsmwBa=0 & LsmwId=0 & Lmwbi.sp & Lmwbi.lp & Lmwbi.gp & Lmwbi.fp & Lmwbi.p1 & Lmwbi.p0 & Lmwbi.r25 & Lmwbi.r24 & Lmwbi.r23 & Lmwbi.r22 & Lmwbi.r21 & Lmwbi.r20 & Lmwbi.r19 & Lmwbi.r18 & Lmwbi.r17 & Lmwbi.r16 & Lmwbi.r15 & Lmwbi.r14 & Lmwbi.r12 & Lmwbi.r12 & Lmwbi.r11 & Lmwbi.r10 & Lmwbi.r9 & Lmwbi.r8 & Lmwbi.r7 & Lmwbi.r6 & Lmwbi.r5 & Lmwbi.r4 & Lmwbi.r3 & Lmwbi.r2 & Lmwbi.r1 & Lmwbi.r0 { }
Lmw.regs: is LsmwBa=0 & LsmwId=1 & Lmwbd.r0 & Lmwbd.r1 & Lmwbd.r2 & Lmwbd.r3 & Lmwbd.r4 & Lmwbd.r5 & Lmwbd.r6 & Lmwbd.r7 & Lmwbd.r8 & Lmwbd.r9 & Lmwbd.r10 & Lmwbd.r11 & Lmwbd.r12 & Lmwbd.r12 & Lmwbd.r14 & Lmwbd.r15 & Lmwbd.r16 & Lmwbd.r17 & Lmwbd.r18 & Lmwbd.r19 & Lmwbd.r20 & Lmwbd.r21 & Lmwbd.r22 & Lmwbd.r23 & Lmwbd.r24 & Lmwbd.r25 & Lmwbd.p0 & Lmwbd.p1 & Lmwbd.fp & Lmwbd.gp & Lmwbd.lp & Lmwbd.sp { }
Lmw.regs: is LsmwBa=1 & LsmwId=0 & Lmwai.sp & Lmwai.lp & Lmwai.gp & Lmwai.fp & Lmwai.p1 & Lmwai.p0 & Lmwai.r25 & Lmwai.r24 & Lmwai.r23 & Lmwai.r22 & Lmwai.r21 & Lmwai.r20 & Lmwai.r19 & Lmwai.r18 & Lmwai.r17 & Lmwai.r16 & Lmwai.r15 & Lmwai.r14 & Lmwai.r12 & Lmwai.r12 & Lmwai.r11 & Lmwai.r10 & Lmwai.r9 & Lmwai.r8 & Lmwai.r7 & Lmwai.r6 & Lmwai.r5 & Lmwai.r4 & Lmwai.r3 & Lmwai.r2 & Lmwai.r1 & Lmwai.r0 { }
Lmw.regs: is LsmwBa=1 & LsmwId=1 & Lmwad.r0 & Lmwad.r1 & Lmwad.r2 & Lmwad.r3 & Lmwad.r4 & Lmwad.r5 & Lmwad.r6 & Lmwad.r7 & Lmwad.r8 & Lmwad.r9 & Lmwad.r10 & Lmwad.r11 & Lmwad.r12 & Lmwad.r12 & Lmwad.r14 & Lmwad.r15 & Lmwad.r16 & Lmwad.r17 & Lmwad.r18 & Lmwad.r19 & Lmwad.r20 & Lmwad.r21 & Lmwad.r22 & Lmwad.r23 & Lmwad.r24 & Lmwad.r25 & Lmwad.p0 & Lmwad.p1 & Lmwad.fp & Lmwad.gp & Lmwad.lp & Lmwad.sp { }
Smw.regs: is LsmwBa=0 & LsmwId=0 & Smwbi.sp & Smwbi.lp & Smwbi.gp & Smwbi.fp & Smwbi.p1 & Smwbi.p0 & Smwbi.r25 & Smwbi.r24 & Smwbi.r23 & Smwbi.r22 & Smwbi.r21 & Smwbi.r20 & Smwbi.r19 & Smwbi.r18 & Smwbi.r17 & Smwbi.r16 & Smwbi.r15 & Smwbi.r14 & Smwbi.r12 & Smwbi.r12 & Smwbi.r11 & Smwbi.r10 & Smwbi.r9 & Smwbi.r8 & Smwbi.r7 & Smwbi.r6 & Smwbi.r5 & Smwbi.r4 & Smwbi.r3 & Smwbi.r2 & Smwbi.r1 & Smwbi.r0 { }
Smw.regs: is LsmwBa=0 & LsmwId=1 & Smwbd.r0 & Smwbd.r1 & Smwbd.r2 & Smwbd.r3 & Smwbd.r4 & Smwbd.r5 & Smwbd.r6 & Smwbd.r7 & Smwbd.r8 & Smwbd.r9 & Smwbd.r10 & Smwbd.r11 & Smwbd.r12 & Smwbd.r12 & Smwbd.r14 & Smwbd.r15 & Smwbd.r16 & Smwbd.r17 & Smwbd.r18 & Smwbd.r19 & Smwbd.r20 & Smwbd.r21 & Smwbd.r22 & Smwbd.r23 & Smwbd.r24 & Smwbd.r25 & Smwbd.p0 & Smwbd.p1 & Smwbd.fp & Smwbd.gp & Smwbd.lp & Smwbd.sp { }
Smw.regs: is LsmwBa=1 & LsmwId=0 & Smwai.sp & Smwai.lp & Smwai.gp & Smwai.fp & Smwai.p1 & Smwai.p0 & Smwai.r25 & Smwai.r24 & Smwai.r23 & Smwai.r22 & Smwai.r21 & Smwai.r20 & Smwai.r19 & Smwai.r18 & Smwai.r17 & Smwai.r16 & Smwai.r15 & Smwai.r14 & Smwai.r12 & Smwai.r12 & Smwai.r11 & Smwai.r10 & Smwai.r9 & Smwai.r8 & Smwai.r7 & Smwai.r6 & Smwai.r5 & Smwai.r4 & Smwai.r3 & Smwai.r2 & Smwai.r1 & Smwai.r0 { }
Smw.regs: is LsmwBa=1 & LsmwId=1 & Smwad.r0 & Smwad.r1 & Smwad.r2 & Smwad.r3 & Smwad.r4 & Smwad.r5 & Smwad.r6 & Smwad.r7 & Smwad.r8 & Smwad.r9 & Smwad.r10 & Smwad.r11 & Smwad.r12 & Smwad.r12 & Smwad.r14 & Smwad.r15 & Smwad.r16 & Smwad.r17 & Smwad.r18 & Smwad.r19 & Smwad.r20 & Smwad.r21 & Smwad.r22 & Smwad.r23 & Smwad.r24 & Smwad.r25 & Smwad.p0 & Smwad.p1 & Smwad.fp & Smwad.gp & Smwad.lp & Smwad.sp { }
Lmwa.regs: is LsmwBa=0 & LsmwId=0 & Lmwbi.sp & Lmwbi.lp & Lmwbi.gp & Lmwbi.fp & Lmwbi.p1 & Lmwbi.p0 & Lmwbi.r25 & Lmwbi.r24 & Lmwbi.r23 & Lmwbi.r22 & Lmwbi.r21 & Lmwbi.r20 & Lmwbi.r19 & Lmwbi.r18 & Lmwbi.r17 & Lmwbi.r16 & Lmwbi.r15 & Lmwbi.r14 & Lmwbi.r12 & Lmwbi.r12 & Lmwbi.r11 & Lmwbi.r10 & Lmwbi.r9 & Lmwbi.r8 & Lmwbi.r7 & Lmwbi.r6 & Lmwbi.r5 & Lmwbi.r4 & Lmwbi.r3 & Lmwbi.r2 & Lmwbi.r1 & Lmwbi.r0 { }
Lmwa.regs: is LsmwBa=0 & LsmwId=1 & Lmwbd.r0 & Lmwbd.r1 & Lmwbd.r2 & Lmwbd.r3 & Lmwbd.r4 & Lmwbd.r5 & Lmwbd.r6 & Lmwbd.r7 & Lmwbd.r8 & Lmwbd.r9 & Lmwbd.r10 & Lmwbd.r11 & Lmwbd.r12 & Lmwbd.r12 & Lmwbd.r14 & Lmwbd.r15 & Lmwbd.r16 & Lmwbd.r17 & Lmwbd.r18 & Lmwbd.r19 & Lmwbd.r20 & Lmwbd.r21 & Lmwbd.r22 & Lmwbd.r23 & Lmwbd.r24 & Lmwbd.r25 & Lmwbd.p0 & Lmwbd.p1 & Lmwbd.fp & Lmwbd.gp & Lmwbd.lp & Lmwbd.sp { }
Lmwa.regs: is LsmwBa=1 & LsmwId=0 & Lmwai.sp & Lmwai.lp & Lmwai.gp & Lmwai.fp & Lmwai.p1 & Lmwai.p0 & Lmwai.r25 & Lmwai.r24 & Lmwai.r23 & Lmwai.r22 & Lmwai.r21 & Lmwai.r20 & Lmwai.r19 & Lmwai.r18 & Lmwai.r17 & Lmwai.r16 & Lmwai.r15 & Lmwai.r14 & Lmwai.r12 & Lmwai.r12 & Lmwai.r11 & Lmwai.r10 & Lmwai.r9 & Lmwai.r8 & Lmwai.r7 & Lmwai.r6 & Lmwai.r5 & Lmwai.r4 & Lmwai.r3 & Lmwai.r2 & Lmwai.r1 & Lmwai.r0 { }
Lmwa.regs: is LsmwBa=1 & LsmwId=1 & Lmwad.r0 & Lmwad.r1 & Lmwad.r2 & Lmwad.r3 & Lmwad.r4 & Lmwad.r5 & Lmwad.r6 & Lmwad.r7 & Lmwad.r8 & Lmwad.r9 & Lmwad.r10 & Lmwad.r11 & Lmwad.r12 & Lmwad.r12 & Lmwad.r14 & Lmwad.r15 & Lmwad.r16 & Lmwad.r17 & Lmwad.r18 & Lmwad.r19 & Lmwad.r20 & Lmwad.r21 & Lmwad.r22 & Lmwad.r23 & Lmwad.r24 & Lmwad.r25 & Lmwad.p0 & Lmwad.p1 & Lmwad.fp & Lmwad.gp & Lmwad.lp & Lmwad.sp { }
Smwa.regs: is LsmwBa=0 & LsmwId=0 & Smwbi.sp & Smwbi.lp & Smwbi.gp & Smwbi.fp & Smwbi.p1 & Smwbi.p0 & Smwbi.r25 & Smwbi.r24 & Smwbi.r23 & Smwbi.r22 & Smwbi.r21 & Smwbi.r20 & Smwbi.r19 & Smwbi.r18 & Smwbi.r17 & Smwbi.r16 & Smwbi.r15 & Smwbi.r14 & Smwbi.r12 & Smwbi.r12 & Smwbi.r11 & Smwbi.r10 & Smwbi.r9 & Smwbi.r8 & Smwbi.r7 & Smwbi.r6 & Smwbi.r5 & Smwbi.r4 & Smwbi.r3 & Smwbi.r2 & Smwbi.r1 & Smwbi.r0 { }
Smwa.regs: is LsmwBa=0 & LsmwId=1 & Smwbd.r0 & Smwbd.r1 & Smwbd.r2 & Smwbd.r3 & Smwbd.r4 & Smwbd.r5 & Smwbd.r6 & Smwbd.r7 & Smwbd.r8 & Smwbd.r9 & Smwbd.r10 & Smwbd.r11 & Smwbd.r12 & Smwbd.r12 & Smwbd.r14 & Smwbd.r15 & Smwbd.r16 & Smwbd.r17 & Smwbd.r18 & Smwbd.r19 & Smwbd.r20 & Smwbd.r21 & Smwbd.r22 & Smwbd.r23 & Smwbd.r24 & Smwbd.r25 & Smwbd.p0 & Smwbd.p1 & Smwbd.fp & Smwbd.gp & Smwbd.lp & Smwbd.sp { }
Smwa.regs: is LsmwBa=1 & LsmwId=0 & Smwai.sp & Smwai.lp & Smwai.gp & Smwai.fp & Smwai.p1 & Smwai.p0 & Smwai.r25 & Smwai.r24 & Smwai.r23 & Smwai.r22 & Smwai.r21 & Smwai.r20 & Smwai.r19 & Smwai.r18 & Smwai.r17 & Smwai.r16 & Smwai.r15 & Smwai.r14 & Smwai.r12 & Smwai.r12 & Smwai.r11 & Smwai.r10 & Smwai.r9 & Smwai.r8 & Smwai.r7 & Smwai.r6 & Smwai.r5 & Smwai.r4 & Smwai.r3 & Smwai.r2 & Smwai.r1 & Smwai.r0 { }
Smwa.regs: is LsmwBa=1 & LsmwId=1 & Smwad.r0 & Smwad.r1 & Smwad.r2 & Smwad.r3 & Smwad.r4 & Smwad.r5 & Smwad.r6 & Smwad.r7 & Smwad.r8 & Smwad.r9 & Smwad.r10 & Smwad.r11 & Smwad.r12 & Smwad.r12 & Smwad.r14 & Smwad.r15 & Smwad.r16 & Smwad.r17 & Smwad.r18 & Smwad.r19 & Smwad.r20 & Smwad.r21 & Smwad.r22 & Smwad.r23 & Smwad.r24 & Smwad.r25 & Smwad.p0 & Smwad.p1 & Smwad.fp & Smwad.gp & Smwad.lp & Smwad.sp { }

###

LsmwBa_: "b" is LsmwBa=0 { }
LsmwBa_: "a" is LsmwBa=1 { }

LsmwId_: "i" is LsmwId=0 { }
LsmwId_: "d" is LsmwId=1 { }

LsmwM_: ""  is LsmwRa & LsmwM=0 { }
LsmwM_: "m" is LsmwRa & LsmwM=1 { LsmwRa = mult_addr; }


:lmw.^LsmwBa_^LsmwId_^LsmwM_ LsmwRb, [LsmwRa], LsmwRe, Enable4 is OpSz=0 & Opc=0b011101 & LsmwRb & LsmwRa & LsmwRe & Enable4 & LsmwLs=0 & LsmwBa_ & LsmwId_ & LsmwM_ & LsmwSub=0b00 & Lmw.regs
{
    mult_addr = LsmwRa;
    build Lmw.regs;
    build LsmwM_;
}

:smw.^LsmwBa_^LsmwId_^LsmwM_ LsmwRb, [LsmwRa], LsmwRe, Enable4 is OpSz=0 & Opc=0b011101 & LsmwRb & LsmwRa & LsmwRe & Enable4 & LsmwLs=1 & LsmwBa_ & LsmwId_ & LsmwM_ & LsmwSub=0b00 & Smw.regs
{
    mult_addr = LsmwRa;
    build Smw.regs;
    build LsmwM_;
}


### Load / Store Instruction for Atomic Updates ###

:llw Rt, AddrRaRbsv is OpSz=0 & Opc=0b011100 & Rt & AddrRaRbsv & Sub8=0b00011000 { Rt = *AddrRaRbsv; }
:scw Rt, AddrRaRbsv is OpSz=0 & Opc=0b011100 & Rt & AddrRaRbsv & Sub8=0b00011001 { *AddrRaRbsv = Rt; }


### Load / Store Instructions with User-mode Privilege ###

# TODO : special constraint (user-mode address translation)

:lwup Rt, AddrRaRbsv is OpSz=0 & Opc=0b011100 & Rt & AddrRaRbsv & Sub8=0b00100010 { Rt = *AddrRaRbsv; }
:swup Rt, AddrRaRbsv is OpSz=0 & Opc=0b011100 & Rt & AddrRaRbsv & Sub8=0b00101010 { *AddrRaRbsv = Rt; }


### Jump Instruction ###

Rel24: addr is Imm24s [ addr = inst_start + (Imm24s << 1); ] { export *:4 addr; }

:j    Rel24 is OpSz=0 & Opc=0b100100   & JIt=0 & Rel24 { goto Rel24; }
:jal  Rel24 is OpSz=0 & Opc=0b100100   & JIt=1 & Rel24 { lp = inst_next; call Rel24; }
:jr   Rb    is OpSz=0 & Opc=0b100101 & Rt=0 & Ra=0 & Rb & DtIt=0b00 & Jz=0 & JrHint=0 & Sub5=0b00000 { goto [Rb]; }
:ret  Rb    is OpSz=0 & Opc=0b100101 & Rt=0 & Ra=0 & Rb & DtIt=0b00 & Jz=0 & JrHint=1 & Sub5=0b00000 { return [Rb]; }
:jral Rt,Rb is OpSz=0 & Opc=0b100101 & Rt & Ra=0 & Rb & DtIt=0b00 & Jz=0 & JrHint=0 & Sub5=0b00001 { Rt = inst_next; call [Rb]; }


### Branch Instruction ###
Rel14: addr is Imm14s [ addr = inst_start + (Imm14s << 1); ] { export *:4 addr; }
Rel16: addr is Imm16s [ addr = inst_start + (Imm16s << 1); ] { export *:4 addr; }

:beq  Rt, Ra, Rel14 is OpSz=0 & Opc=0b100110 & Rt & Ra & Br1t=0 & Rel14 { if(Rt == Ra) goto Rel14; }
:bne  Rt, Ra, Rel14 is OpSz=0 & Opc=0b100110 & Rt & Ra & Br1t=1 & Rel14 { if(Rt != Ra) goto Rel14; }
:beqz Rt,     Rel16 is OpSz=0 & Opc=0b100111 & Rt & Br2t=0b0010 & Rel16 { if(Rt == 0)  goto Rel16; }
:bnez Rt,     Rel16 is OpSz=0 & Opc=0b100111 & Rt & Br2t=0b0011 & Rel16 { if(Rt != 0)  goto Rel16; }
:bgez Rt,     Rel16 is OpSz=0 & Opc=0b100111 & Rt & Br2t=0b0100 & Rel16 { if(Rt s>= 0) goto Rel16; }
:bltz Rt,     Rel16 is OpSz=0 & Opc=0b100111 & Rt & Br2t=0b0101 & Rel16 { if(Rt s< 0)  goto Rel16; }
:bgtz Rt,     Rel16 is OpSz=0 & Opc=0b100111 & Rt & Br2t=0b0110 & Rel16 { if(Rt s> 0)  goto Rel16; }
:blez Rt,     Rel16 is OpSz=0 & Opc=0b100111 & Rt & Br2t=0b0111 & Rel16 { if(Rt s<= 0) goto Rel16; }


### Branch with link Instruction ###

:bgezal Rt, Rel16 is OpSz=0 & Opc=0b100111 & Rt & Br2t=0b1100 & Rel16
{
    lp = inst_next;
    if(Rt s>= 0) goto <end>;
        call Rel16;
    <end>
}

:bltzal Rt, Rel16 is OpSz=0 & Opc=0b100111 & Rt & Br2t=0b1101 & Rel16
{
    lp = inst_next;
    if(Rt s< 0) goto <end>;
        call Rel16;
    <end>
}


### Read / Write System Registers ###

# TODO : special instruction, do we create the system registers ?
define pcodeop mfsr;
define pcodeop mtsr;

:mfsr Rt, SrIdx is OpSz=0 & Opc=0b110010 & Rt & SrIdx & Rd=0 & Sub5=0b00010 { Rt = mfsr(SrIdx:4); }
:mtsr Rt, SrIdx is OpSz=0 & Opc=0b110010 & Rt & SrIdx & Rd=0 & Sub5=0b00011 { mtsr(SrIdx:4, Rt:4); }


### Jump Register with System Register Update ###

# TODO : special constraint (address translation off)

:jr.itoff  Rb    is OpSz=0 & Opc=0b100101 & Rt=0 & Ra=0 & Rb & DtIt=0b01 & Jz=0 & JrHint=0 & Sub5=0b00000 { goto [Rb]; }
:jr.toff   Rb    is OpSz=0 & Opc=0b100101 & Rt=0 & Ra=0 & Rb & DtIt=0b11 & Jz=0 & JrHint=0 & Sub5=0b00000 { goto [Rb]; }
:jral.iton Rt,Rb is OpSz=0 & Opc=0b100101 & Rt   & Ra=0 & Rb & DtIt=0b01 & Jz=0 & JrHint=0 & Sub5=0b00001 { Rt = inst_next; call [Rb]; }
:jral.ton  Rt,Rb is OpSz=0 & Opc=0b100101 & Rt   & Ra=0 & Rb & DtIt=0b11 & Jz=0 & JrHint=0 & Sub5=0b00001 { Rt = inst_next; call [Rb]; }


### MMU Instruction ###

define pcodeop TLB_TargetRead;
define pcodeop TLB_TargetWrite;
define pcodeop TLB_RWrite;
define pcodeop TLB_RWriteLock;
define pcodeop TLB_Unlock;
define pcodeop TLB_Probe;
define pcodeop TLB_Invalidate;
define pcodeop TLB_FlushAll;

:tlbop Ra,"TargetRead"  is OpSz=0 & Opc=0b110010 & Rt & Ra & Rb=0 & TlbopSub=0 & Sub5=0b01110 { TLB_TargetRead(Ra:4); }
:tlbop Ra,"TargetWrite" is OpSz=0 & Opc=0b110010 & Rt & Ra & Rb=0 & TlbopSub=1 & Sub5=0b01110 { TLB_TargetWrite(Ra:4); }
:tlbop Ra,"RWrite"      is OpSz=0 & Opc=0b110010 & Rt & Ra & Rb=0 & TlbopSub=2 & Sub5=0b01110 { TLB_RWrite(Ra:4); }
:tlbop Ra,"RWriteLock"  is OpSz=0 & Opc=0b110010 & Rt & Ra & Rb=0 & TlbopSub=3 & Sub5=0b01110 { TLB_RWriteLock(Ra:4); }
:tlbop Ra,"Unlock"      is OpSz=0 & Opc=0b110010 & Rt & Ra & Rb=0 & TlbopSub=4 & Sub5=0b01110 { TLB_Unlock(Ra:4); }
:tlbop Rt,Ra,"Probe"    is OpSz=0 & Opc=0b110010 & Rt & Ra & Rb=0 & TlbopSub=5 & Sub5=0b01110 { TLB_Probe(Rt:4, Ra:4); }
:tlbop Ra,"Invalidate"  is OpSz=0 & Opc=0b110010 & Rt & Ra & Rb=0 & TlbopSub=6 & Sub5=0b01110 { TLB_Invalidate(Ra:4); }
:tlbop "FlushAll"       is OpSz=0 & Opc=0b110010 & Rt & Ra & Rb=0 & TlbopSub=7 & Sub5=0b01110 { TLB_FlushAll(); }


### Conditional Move ###

:cmovz Rt, Ra, Rb is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rd=0 & Sub5=0b11010
{
    if(Rb != 0) goto <end>;
        Rt = Ra;
    <end>
}

:cmovn Rt, Ra, Rb is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rd=0 & Sub5=0b11011
{
    if(Rb == 0) goto <end>;
        Rt = Ra;
    <end>
}


### Synchronization Instruction ###

# TODO : special function, and subfunctions

define pcodeop msync;
define pcodeop isync;

:msync MsyncSub is OpSz=0 & Opc=0b110010 & Rt=0 & MsyncZ=0 & MsyncSub & Sub5=0b01100 { msync(MsyncSub:1); }
:isync Rt       is OpSz=0 & Opc=0b110010 & Rt & Ra=0 & Rb=0 & Rd=0    & Sub5=0b01101 { isync(Rt:4); }

### Prefetch Instruction ###

define pcodeop dpref;

OffsetRbsv2: (Rb "<<" sv) is Rb & sv { off:4 = Rb << (sv + 1); export off; }
AddrRaRbsv2: [Ra + OffsetRbsv2] is Ra & OffsetRbsv2 { addr:4 = Ra + OffsetRbsv2; export addr; }

:dpref DprefSub, AddrRaRbsv2 is OpSz=0 & Opc=0b011100 & DprefD=0 & DprefSub & AddrRaRbsv2 & Sub8=0b00010011 {
    dpref(DprefSub:1, AddrRaRbsv2:4);
}

DprefD_: "w" is DprefD=0 { }
DprefD_: "d" is DprefD=1 { }

DprefiAddr: [Ra + Offset] is DprefD=0 & Ra & Imm15s [ Offset = Imm15s << 2; ] { export *[const]:4 Offset; }
DprefiAddr: [Ra + Offset] is DprefD=1 & Ra & Imm15s [ Offset = Imm15s << 3; ] { export *[const]:4 Offset; }

:dprefi.^DprefD_ DprefSub, DprefiAddr is OpSz=0 & Opc=0b010011 & DprefD_ & DprefSub & DprefiAddr {
    dpref(DprefSub:1, DprefiAddr:4);
}


### NOP Instruction ###

:nop is OpSz=0 & Opc=0b100000 & Rt=0 & Ra=0 & Imm5u=0 & Rd=0 & Sub5=0b01001 { }


### Serialization Instruction ###

define pcodeop dsb;
define pcodeop isb;

:dsb is OpSz=0 & Opc=0b110010 & Rt=0 & Ra=0 & Rb=0 & Rd=0 & Sub5=0b01000 { dsb(); }
:isb is OpSz=0 & Opc=0b110010 & Rt=0 & Ra=0 & Rb=0 & Rd=0 & Sub5=0b01001 { isb(); }


### Exception Generation Instruction ###

define pcodeop break;
define pcodeop syscall;
define pcodeop trap;

:break   Swid is OpSz=0 & Opc=0b110010 & Rt=0 & Swid & Sub5=0b01010 { break(Swid:4); }
:syscall Swid is OpSz=0 & Opc=0b110010 & Rt=0 & Swid & Sub5=0b01011 { syscall(Swid:4); }
:trap    Swid is OpSz=0 & Opc=0b110010 & Rt=0 & Swid & Sub5=0b00101 { trap(Swid:4); }

:teqz Rt, Swid is OpSz=0 & Opc=0b110010 & Rt & Swid & Sub5=0b00110
{
    if(Rt != 0) goto <end>;
        trap(Swid:4);
    <end>
}

:tnez Rt, Swid is OpSz=0 & Opc=0b110010 & Rt & Swid & Sub5=0b00111
{
    if(Rt == 0) goto <end>;
        trap(Swid:4);
    <end>
}


### Special Return Instruction ###

:iret is OpSz=0 & Opc=0b110010 & Rt=0 & Ra=0 & Rb=0 & Rd=0 & Sub5=0b00100 { return [ipc]; }

# TODO : special constraint (address translation off)
:ret.itoff Rb is OpSz=0 & Opc=0b100101 & Rt=0 & Ra=0 & Rb & DtIt=0b01 & Jz=0 & JrHint=1 & Sub5=0b00000 { return [Rb]; }
:ret.toff  Rb is OpSz=0 & Opc=0b100101 & Rt=0 & Ra=0 & Rb & DtIt=0b11 & Jz=0 & JrHint=1 & Sub5=0b00000 { return [Rb]; }


### Cache Control Instruction ###

# TODO : special function, with subfunctions
define pcodeop cctl;

:cctl Rt, Ra, CctlLevel, CctlSub is OpSz=0 & Opc=0b110010 & Rt & Ra & CctlZ=0 & CctlLevel & CctlSub & Sub5=0b00001 { cctl(Rt:4, Ra:4, CctlLevel:1, CctlSub:1); }


# Miscellaneous Instructions (Baseline)

# TODO : special function. Not sure if we use context or registers for this.

define pcodeop setgie;

SetgieEN: "d" is Toggle=0 { setgie(0:1); }
SetgieEN: "e" is Toggle=1 { setgie(1:1); }

:setgie.^SetgieEN is OpSz=0 & Opc=0b110010 & ToggleL=0 & SetgieEN & SrIdx=0b0010000000 & Rd=0b00010 & Sub5=0b00011 { }

define pcodeop setend;

SetendBE: "l" is Toggle=0 { setend(0:1); }
SetendBE: "b" is Toggle=1 { setend(1:1); }

:setend.^SetendBE is OpSz=0 & Opc=0b110010 & ToggleL=0 & SetendBE & SrIdx=0b0010000000 & Rd=0b00001 & Sub5=0b00011 { }

:standby StandbySub is OpSz=0 & Opc=0b110010 & Rt=0 & Ra=0 & Rb=0 & StandbyZ=0 & StandbySub & Sub5=0b00000 { goto inst_start; }



### 32-bit Baseline V2 instructions ###

### ALU Instructions ###

:addi.gp is OpSz=0 & Opc=0b011111 & Rt & GpSub1=0b1 & Imm19s { Rt = gp + Imm19s; }


### Multiply and Divide Instructions (V2) ###

:mulr64 Rt, Ra, Rb is OpSz=0 & Opc=0b100001 & Rt & Ra & Rb & Alu2Mod=0b0001 & Sub6=0b101001 & Rtl & Rth
{
    res:8 = zext(Ra) * zext(Rb);
#@if ENDIAN == "big"
#    Rtl = res(4);
#    Rth = res:4;
#@else
    Rtl = res:4;
    Rth = res(4);
#@endif
}

:mulsr64 Rt, Ra, Rb is OpSz=0 & Opc=0b100001 & Rt & Ra & Rb & Alu2Mod=0b0001 & Sub6=0b101000 & Rtl & Rth
{
    res:8 = sext(Ra) * sext(Rb);
#@if ENDIAN == "big"
#    Rtl = res(4);
#    Rth = res:4;
#@else
    Rtl = res:4;
    Rth = res(4);
#@endif
}

:maddr32 Rt, Ra, Rb is OpSz=0 & Opc=0b100001 & Rt & Ra & Rb & Alu2Mod=0b0001 & Sub6=0b110011 { Rt = Rt + (Ra * Rb); }
:msubr32 Rt, Ra, Rb is OpSz=0 & Opc=0b100001 & Rt & Ra & Rb & Alu2Mod=0b0001 & Sub6=0b110101 { Rt = Rt - (Ra * Rb); }
:divr    Rt, Rs, Ra, Rb is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rs & Sub5=0b10111 { local div = Ra / Rb; local mod = Ra % Rb; Rs = mod; Rt = div; }
:divsr   Rt, Rs, Ra, Rb is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rs & Sub5=0b10110 { local div = Ra s/ Rb; local mod = Ra s% Rb; Rs = mod; Rt = div; }


### Load/Store Instructions ###

GpByteAddress: [+ off] is Imm19s [ off = Imm19s << 0; ] { addr:4 = gp + off; export addr; }
GpHalfAddress: [+ off] is Imm18s [ off = Imm18s << 1; ] { addr:4 = gp + off; export addr; }
GpWordAddress: [+ off] is Imm17s [ off = Imm17s << 2; ] { addr:4 = gp + off; export addr; }

:lbi.gp Rt,  GpByteAddress is OpSz=0 & Opc=0b010111 & Rt & GpSub1=0b0   & GpByteAddress { local tmp:1 = *GpByteAddress; Rt = zext(tmp); }
:lbsi.gp Rt, GpByteAddress is OpSz=0 & Opc=0b010111 & Rt & GpSub1=0b1   & GpByteAddress { local tmp:1 = *GpByteAddress; Rt = sext(tmp); }
:lhi.gp Rt,  GpHalfAddress is OpSz=0 & Opc=0b011110 & Rt & GpSub2=0b00  & GpHalfAddress { local tmp:2 = *GpHalfAddress; Rt = zext(tmp); }
:lhsi.gp Rt, GpHalfAddress is OpSz=0 & Opc=0b011110 & Rt & GpSub2=0b01  & GpHalfAddress { local tmp:2 = *GpHalfAddress; Rt = sext(tmp); }
:lwi.gp Rt,  GpWordAddress is OpSz=0 & Opc=0b011110 & Rt & GpSub3=0b110 & GpWordAddress { Rt = *GpWordAddress; }
:sbi.gp Rt,  GpByteAddress is OpSz=0 & Opc=0b011111 & Rt & GpSub1=0b0   & GpByteAddress { local tmp = Rt; *GpByteAddress = tmp:1; }
:shi.gp Rt,  GpHalfAddress is OpSz=0 & Opc=0b011110 & Rt & GpSub2=0b10  & GpHalfAddress { local tmp = Rt; *GpHalfAddress = tmp:2; }
:swi.gp Rt,  GpWordAddress is OpSz=0 & Opc=0b011110 & Rt & GpSub3=0b111 & GpWordAddress { *GpWordAddress = Rt; }

# TODO : same as lmw/smw, this is horrible

:lmwa.^LsmwBa_^LsmwId_^LsmwM_ LsmwRb, [LsmwRa], LsmwRe, Enable4 is OpSz=0 & Opc=0b011101 & LsmwRb & LsmwRa & LsmwRe & Enable4 & LsmwLs=0 & LsmwBa_ & LsmwId_ & LsmwM_ & LsmwSub=0b01 & Lmwa.regs
{
    mult_addr = LsmwRa;
    build Lmwa.regs;
    build LsmwM_;
}

:smwa.^LsmwBa_^LsmwId_^LsmwM_ LsmwRb, [LsmwRa], LsmwRe, Enable4 is OpSz=0 & Opc=0b011101 & LsmwRb & LsmwRa & LsmwRe & Enable4 & LsmwLs=1 & LsmwBa_ & LsmwId_ & LsmwM_ & LsmwSub=0b01 & Smwa.regs
{
    mult_addr = LsmwRa;
    build Smwa.regs;
    build LsmwM_;
}

:lbup Rt, AddrRaRbsv is OpSz=0 & Opc=0b011100 & Rt & AddrRaRbsv & Sub8=0b00100000 { local tmp:1 = *AddrRaRbsv; Rt = zext(tmp); }
:sbup Rt, AddrRaRbsv is OpSz=0 & Opc=0b011100 & Rt & AddrRaRbsv & Sub8=0b00101000 { local tmp = Rt; *AddrRaRbsv = tmp:1; }

#@endif



### 32-bit Baseline V3 instructions ###

#@if defined(BASELINE_V3)

### ALU Instructions with Shift Operation (v3) ###

:add_slli Rt, Ra, Rb, sh is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & sh & Sub5=0b00000 { Rt = Ra + (Rb << sh); }
:and_slli Rt, Ra, Rb, sh is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & sh & Sub5=0b00010 { Rt = Ra & (Rb << sh); }
:or_slli  Rt, Ra, Rb, sh is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & sh & Sub5=0b00100 { Rt = Ra | (Rb << sh); }
:sub_slli Rt, Ra, Rb, sh is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & sh & Sub5=0b00001 { Rt = Ra - (Rb << sh); }
:xor_slli Rt, Ra, Rb, sh is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & sh & Sub5=0b00011 { Rt = Ra ^ (Rb << sh); }

:add_srli Rt, Ra, Rb, sh is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & sh & Sub5=0b11100 { Rt = Ra + (Rb << sh); }
:and_srli Rt, Ra, Rb, sh is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & sh & Sub5=0b11110 { Rt = Ra & (Rb << sh); }
:or_srli  Rt, Ra, Rb, sh is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & sh & Sub5=0b10101 { Rt = Ra | (Rb << sh); }
:sub_srli Rt, Ra, Rb, sh is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & sh & Sub5=0b11101 { Rt = Ra - (Rb << sh); }
:xor_srli Rt, Ra, Rb, sh is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & sh & Sub5=0b11111 { Rt = Ra ^ (Rb << sh); }

### Conditional Branch and Jump Instructions (V3) ###

Rel8: addr is Imm8s [ addr = inst_start + (Imm8s << 1); ] { export *:4 addr; }
:beqc  Rt, Imm11s, Rel8 is OpSz=0 & Opc=0b101101 & Rt & Bxxc=0 & Imm11s & Rel8 { if(Rt == Imm11s) goto Rel8; }
:bnec  Rt, Imm11s, Rel8 is OpSz=0 & Opc=0b101101 & Rt & Bxxc=1 & Imm11s & Rel8 { if(Rt != Imm11s) goto Rel8; }

:jralnez Rt,Rb is OpSz=0 & Opc=0b100101 & Rt & Ra=0 & Rb & DtIt=0b00 & Jz=0 & JrHint=0 & Sub5=0b00011 { if(Rb == 0) goto <end>; Rt = inst_next; call [Rb]; <end> }
:jrnez   Rb    is OpSz=0 & Opc=0b100101 & Rt=0 & Ra=0 & Rb & DtIt=0b00 & Jz=0 & JrHint=0 & Sub5=0b00010 { if(Rb == 0) goto <end>; goto [Rb]; <end> }

### Bit Manipulation Instructions (V3) ###

:bitc  Rt, Ra, Rb     is OpSz=0 & Opc=0b100000 & Rt & Ra & Rb & Rd=0 & Sub5=0b10010 { Rt = Ra & (~Rb); }
:bitci Rt, Ra, Imm15u is OpSz=0 & Opc=0b110011 & Rt & Ra & Imm15u { Rt = Ra & (~Imm15u); }

### Cache Control Instruction (V3) ###

# TODO: Add CCTL L1D_WBALL, level

#@endif



### 32-bit ISA extension ###

### ALU Instruction (Performance) ###

#@if defined(PERFORMANCE_V1)

:abs Rt, Ra is OpSz=0 & Opc=0b100001 & Rt & Ra & Rb=0 & Alu2Mod=0b0000 & Sub6=0b000011
{
    gez:4 = zext(Ra s>= 0);
    ltz:4 = zext(Ra s< 0);
    Rt = (Ra * gez) | ((-Ra) * ltz);
}

:ave Rt, Ra, Rb is OpSz=0 & Opc=0b100001 & Rt & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b000010
{
    Rt = (Ra + Rb + 1) s>> 2;
}

:max Rt, Ra, Rb is OpSz=0 & Opc=0b100001 & Rt & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b000000
{
    altb:4 = zext(Ra s< Rb);
    ageb:4 = zext(Ra s>= Rb);
    Rt = (Ra * ageb) | (Rb * altb);
}

:min Rt, Ra, Rb is OpSz=0 & Opc=0b100001 & Rt & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b000001
{
    altb:4 = zext(Ra s< Rb);
    ageb:4 = zext(Ra s>= Rb);
    Rt = (Ra * altb) | (Rb * ageb);
}

:bset Rt, Ra, Imm5u is OpSz=0 & Opc=0b100001 & Rt & Ra & Imm5u & Alu2Mod=0b0000 & Sub6=0b001000 { Rt = Ra | (1 << Imm5u); }
:bclr Rt, Ra, Imm5u is OpSz=0 & Opc=0b100001 & Rt & Ra & Imm5u & Alu2Mod=0b0000 & Sub6=0b001001 { Rt = Ra & ~(1 << Imm5u); }
:btgl Rt, Ra, Imm5u is OpSz=0 & Opc=0b100001 & Rt & Ra & Imm5u & Alu2Mod=0b0000 & Sub6=0b001010 { Rt = Ra ^ (1 << Imm5u); }
:btst Rt, Ra, Imm5u is OpSz=0 & Opc=0b100001 & Rt & Ra & Imm5u & Alu2Mod=0b0000 & Sub6=0b001011 { Rt = (Ra >> Imm5u) & 1; }

:clips Rt, Ra, Imm5u is OpSz=0 & Opc=0b100001 & Rt & Ra & Imm5u & Alu2Mod=0b0000 & Sub6=0b000100
{
    local upper:4 = (1 << Imm5u) - 1;
    local lower:4 = -(1 << Imm5u);
    if(Ra s<= upper) goto <elif>;
        Rt = upper;
        goto <end>;
    <elif>
    if(Ra s>= lower) goto <else>;
        Rt = lower;
        goto <end>;
    <else>
        Rt = Ra;
    <end>
}
:clip Rt, Ra, Imm5u is OpSz=0 & Opc=0b100001 & Rt & Ra & Imm5u & Alu2Mod=0b0000 & Sub6=0b000101
{
    local upper:4 = (1 << Imm5u) - 1;
    if(Ra s<= upper) goto <elif>;
        Rt = upper;
        goto <end>;
    <elif>
    if(Ra s>= 0) goto <else>;
        Rt = 0;
        goto <end>;
    <else>
        Rt = Ra;
    <end>
}

:clz Rt, Ra is OpSz=0 & Opc=0b100001 & Rt & Ra & Imm5u=0 & Alu2Mod=0b0000 & Sub6=0b000111
{
  countTmp:4 = 0;
  inputTmp:4 = Ra;

 <loopbegin>
  if ((inputTmp & 0x80000000) != 0) goto <loopend>;

  countTmp = countTmp + 1;
  inputTmp = (inputTmp << 1) | 1;
  goto <loopbegin>;

 <loopend>
  Rt = countTmp;
}

:clo Rt, Ra is OpSz=0 & Opc=0b100001 & Rt & Ra & Imm5u=0 & Alu2Mod=0b0000 & Sub6=0b000110
{
  countTmp:4 = 0;
  inputTmp:4 = Ra;

 <loopbegin>
  if ((inputTmp & 0x80000000) == 0) goto <loopend>;

  countTmp = countTmp + 1;
  inputTmp = (inputTmp << 1) | 1;
  goto <loopbegin>;

 <loopend>
  Rt = countTmp;
}

#@endif


### Performance Extension V2 ###

#if defined(PERFORMANCE_V2)

# TODO : arithmetic functions: bs*
:bse is OpSz=0 & Opc=0b100001 & Rt & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b001100 unimpl
:bsp is OpSz=0 & Opc=0b100001 & Rt & Ra & Rb & Alu2Mod=0b0000 & Sub6=0b001101 unimpl

macro add_abs_diff(dst, src1, src2, shift)
{
    local src1_ = src1 >> shift;
    local src2_ = src2 >> shift;
    local src1__ = src1_:1;
    local src2__ = src2_:1;
    local a:1 = src1__ - src2__;
    local agez:1 = zext(a s>= 0);
    local altz:1 = zext(a s< 0);
    local aabs:1 = (a * agez) | ((-a) * altz);
    dst = dst + zext(aabs);
}
:pbsad Rt, Ra, Rb is OpSz=0 & Opc=0b111000 & Rt & Ra & Rb & Rd=0 & Sub5=0b0000
{
    Rt = 0;
    add_abs_diff(Rt, Ra, Rb, 0);
    add_abs_diff(Rt, Ra, Rb, 8);
    add_abs_diff(Rt, Ra, Rb, 16);
    add_abs_diff(Rt, Ra, Rb, 24);
}
:pbsada Rt, Ra, Rb is OpSz=0 & Opc=0b111000 & Rt & Ra & Rb & Rd=0 & Sub5=0b0001
{
    add_abs_diff(Rt, Ra, Rb, 0);
    add_abs_diff(Rt, Ra, Rb, 8);
    add_abs_diff(Rt, Ra, Rb, 16);
    add_abs_diff(Rt, Ra, Rb, 24);
}

# @endif

########### 16b ############

define token instr16(16)
    opsz        = (15, 15)
    opc4        = (11, 14)
    opc5        = (10, 14)
    opc6        = (9, 14)
    opc7        = (8, 14)
    opc8        = (7, 14)
    opc10       = (5, 14)
    re2         = (5, 6)
    rr21         = (5, 9)
    ra4         = (5, 8)
    rr20         = (5, 8)
    ra5         = (0, 4)
    rb5         = (0, 4)
    rr21b        = (0, 4)
    rr19         = (6, 8)
    rr19b        = (8, 10)
    ra3         = (3, 5)
    rb3         = (0, 2)
    imm3u       = (0, 2)
    imm3ub      = (3, 5)
    imm5u       = (0, 4)
    imm5s       = (0, 4) signed
    imm6u       = (0, 5)
    imm7u       = (0, 6)
    imm8s       = (0, 7) signed
    imm10s      = (0, 9) signed
    xwi37_ls    = (7, 7)
    swid9       = (0, 8)
    rr21e1       = (4, 7)
    rr21e2       = (4, 7)
    ra5e1       = (0, 3)
    ra5e2       = (0, 3)
;

attach variables [rr21 ra5 rb5 rr21b] [
    r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r12 r14 r15 r16 r17 r18 r19 r20 r21 r22 r23 r24 r25 p0 p1 fp gp lp sp
];

attach variables [ra4 rr20] [
    r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r16 r17 r18 r19
];

attach variables [rr19 ra3 rr19b rb3] [
    r0 r1 r2 r3 r4 r5 r6 r7
];

attach variables [ra5e1 rr21e1] [
    r0 r2 r4 r6 r8 r10 r12 r14 r16 r18 r20 r22 r24 p0 fp lp
];
attach variables [ra5e2 rr21e2] [
    r1 r3 r5 r7 r9 r11 r12 r15 r17 r19 r21 r23 r25 p1 gp sp
];
attach variables [re2] [
    r6 r8 r10 r14
];
### Move Instruction ###
:movi55 rr21, imm5s is opsz=1 & opc5=0b00001 & rr21 & imm5s { rr21 = imm5s; }
:mov55  rr21,   ra5 is opsz=1 & opc5=0b00000 & rr21 & ra5   { rr21 = ra5; }


### Add/Sub Instruction with Immediate ###

:addi45  rr20,      imm5u is opsz=1 & opc6=0b000110 & rr20       & imm5u { rr20 = rr20 + imm5u; }
:addi333 rr19, ra3, imm3u is opsz=1 & opc6=0b001110 & rr19 & ra3 & imm3u { rr19 = ra3 + imm3u; }
:subi45  rr20,      imm5u is opsz=1 & opc6=0b000111 & rr20       & imm5u { rr20 = rr20 - imm5u; }
:subi333 rr19, ra3, imm3u is opsz=1 & opc6=0b001111 & rr19 & ra3 & imm3u { rr19 = ra3 - imm3u; }


### Add/Sub Instruction ###

:add45   rr20,      rb5 is opsz=1 & opc6=0b000100 & rr20       & rb5 { rr20 = rr20 + rb5; }
:add333  rr19, ra3, rb3 is opsz=1 & opc6=0b001100 & rr19 & ra3 & rb3 { rr19 = ra3 + rb3; }
:sub45   rr20,      rb5 is opsz=1 & opc6=0b000101 & rr20       & rb5 { rr20 = rr20 - rb5; }
:sub333  rr19, ra3, rb3 is opsz=1 & opc6=0b001101 & rr19 & ra3 & rb3 { rr19 = ra3 - rb3; }


### Shift Instruction with Immediate ###

:srai45  rr20,      imm5u is opsz=1 & opc6=0b001000 & rr20       & imm5u { rr20 = rr20 s>> imm5u; }
:srli45  rr20,      imm5u is opsz=1 & opc6=0b001001 & rr20       & imm5u { rr20 = rr20 >> imm5u; }
:slli333 rr19, ra3, imm3u is opsz=1 & opc6=0b001010 & rr19 & ra3 & imm3u { rr19 = ra3 << imm3u; }


### Bit Field Mask Instruction with Immediate ###

:zeb33  rr19, ra3 is opsz=1 & opc6=0b001011 & rr19 & ra3 & imm3u=0b000 { local tmp = ra3; rr19 = zext(tmp:1); }
:zeh33  rr19, ra3 is opsz=1 & opc6=0b001011 & rr19 & ra3 & imm3u=0b001 { local tmp = ra3; rr19 = zext(tmp:2); }
:seb33  rr19, ra3 is opsz=1 & opc6=0b001011 & rr19 & ra3 & imm3u=0b010 { local tmp = ra3; rr19 = sext(tmp:1); }
:seh33  rr19, ra3 is opsz=1 & opc6=0b001011 & rr19 & ra3 & imm3u=0b011 { local tmp = ra3; rr19 = sext(tmp:2); }
:xlsb33 rr19, ra3 is opsz=1 & opc6=0b001011 & rr19 & ra3 & imm3u=0b100 { rr19 = ra3 & 1; }
:x11b33 rr19, ra3 is opsz=1 & opc6=0b001011 & rr19 & ra3 & imm3u=0b101 { rr19 = ra3 & 0x7ff; }


### Load / Store Instruction ###

:lwi450 rr20,[ra5] is opsz=1 & opc6=0b011010 & rr20 & ra5 { rr20 = *ra5; }

rel3w: off is imm3u [ off = imm3u << 2; ] { export *[const]:4 off; }
rel3h: off is imm3u [ off = imm3u << 1; ] { export *[const]:4 off; }
rel3b: off is imm3u [ off = imm3u << 0 ; ] { export *[const]:4 off; }
ra3_rel3w: [ra3 + rel3w] is ra3 & rel3w { addr:4 = ra3 + rel3w; export addr; }
ra3_rel3h: [ra3 + rel3h] is ra3 & rel3h { addr:4 = ra3 + rel3h; export addr; }
ra3_rel3b: [ra3 + rel3b] is ra3 & rel3b { addr:4 = ra3 + rel3b; export addr; }

:lwi333    rr19, ra3_rel3w    is opsz=1 & opc6=0b010000 & rr19 & ra3_rel3w   { rr19 = *ra3_rel3w; }
:lwi333.bi rr19, [ra3], rel3w is opsz=1 & opc6=0b010001 & rr19 & ra3 & rel3w { rr19 = *ra3; ra3 = ra3 + rel3w; }
:lhi333    rr19, ra3_rel3h    is opsz=1 & opc6=0b010010 & rr19 & ra3_rel3h   { local tmp:2 = *ra3_rel3h; rr19 = zext(tmp); }
:lbi333    rr19, ra3_rel3b    is opsz=1 & opc6=0b010011 & rr19 & ra3_rel3b   { local tmp:1 = *ra3_rel3b; rr19 = zext(tmp); }
:swi450    rr20, [ra5]        is opsz=1 & opc6=0b011011 & rr20 & ra5         { *ra5 = rr20; }
:swi333    rr19, ra3_rel3w    is opsz=1 & opc6=0b010100 & rr19 & ra3_rel3w   { *ra3_rel3w = rr19; }
:swi333.bi rr19, [ra3], rel3w is opsz=1 & opc6=0b010101 & rr19 & ra3 & rel3w { *ra3 = rr19; ra3 = ra3 + rel3w; }
:shi333    rr19, ra3_rel3h    is opsz=1 & opc6=0b010110 & rr19 & ra3_rel3h   { local tmp = rr19; *ra3_rel3h = tmp:2; }
:sbi333    rr19, ra3_rel3b    is opsz=1 & opc6=0b010111 & rr19 & ra3_rel3b   { local tmp = rr19; *ra3_rel3b = tmp:1; }


### Load/Store Instruction with Implied FP ###

rel7w: off is imm7u [ off = imm7u << 2; ] { export *[const]:4 off; }
fp_rel7w: [fp + rel7w] is fp & rel7w { addr:4 = fp + rel7w; export addr; }

:lwi37 rr19b, fp_rel7w is opsz=1 & rr19b & opc4=0b0111 & xwi37_ls=0 & fp_rel7w { rr19b = *fp_rel7w; }
:swi37 rr19b, fp_rel7w is opsz=1 & rr19b & opc4=0b0111 & xwi37_ls=1 & fp_rel7w { *fp_rel7w = rr19b; }


### Branch and Jump Instruction ###

rel8: addr is imm8s [ addr = inst_start + (imm8s << 1); ] { export *:4 addr; }


:beqs38 rr19b,rel8 is opsz=1 & opc4=0b1010 & rr19b & rel8 { if(r5 == rr19b) goto rel8; }
:bnes38 rr19b,rel8 is opsz=1 & opc4=0b1011 & rr19b & rel8 { if(r5 != rr19b) goto rel8; }
:beqz38 rr19b,rel8 is opsz=1 & opc4=0b1000 & rr19b & rel8 { if(rr19b == 0) goto rel8; }
:bnez38 rr19b,rel8 is opsz=1 & opc4=0b1001 & rr19b & rel8 { if(rr19b != 0) goto rel8; }

:j8    rel8 is opsz=1 & opc7=0b1010101     & rel8 { goto rel8; }
:jr5   rb5  is opsz=1 & opc10=0b1011101000 & rb5  { goto [rb5]; }
:rer21  rb5  is opsz=1 & opc10=0b1011101100 & rb5  { return [rb5]; }
:jral5 rb5  is opsz=1 & opc10=0b1011101001 & rb5  { lp = inst_next; call [rb5]; }


### Compare and Branch Instruction ###

:slti45  ra4, imm5u is opsz=1 & opc6=0b110011 & ra4 & imm5u { r15 = zext(ra4 < imm5u); }
:sltsi45 ra4, imm5u is opsz=1 & opc6=0b110010 & ra4 & imm5u { r15 = zext(ra4 s< imm5u); }
:slr205   ra4, rb5   is opsz=1 & opc6=0b110001 & ra4 & rb5   { r15 = zext(ra4 < rb5); }
:slts45  ra4, rb5   is opsz=1 & opc6=0b110000 & ra4 & rb5   { r15 = zext(ra4 s< rb5); }

:beqzs8 rel8 is opsz=1 & opc7=0b1101000 & rel8 { if(r15 == 0) goto rel8; }
:bnezs8 rel8 is opsz=1 & opc7=0b1101001 & rel8 { if(r15 != 0) goto rel8; }


### Misc Instruction ###

:break16 swid9 is opsz=1 & opc6=0b110101 & swid9 { break(swid9:4); }
:nop16 is opsz=1 & opc6=0b001001 & rr20=0b0000 & imm5u=0b00000 { }


### ALU Instructions (V2) ###

#@if defined(BASELINE_V2)

:addi10.sp imm10s is opsz=1 & opc5=0b11011 & imm10s { sp = sp + imm10s; }


### Load/Store Instruction (V2) ###

sp_rel7w: [+ rel7w] is rel7w { addr:4 = sp + rel7w; export addr; }

:lwi37.sp rr19b, sp_rel7w is opsz=1 & rr19b & opc4=0b1110 & xwi37_ls=0 & sp_rel7w { rr19b = *sp_rel7w; }
:swi37.sp rr19b, sp_rel7w is opsz=1 & rr19b & opc4=0b1110 & xwi37_ls=1 & sp_rel7w { *sp_rel7w = rr19b; }

#@endif



### 16-bit Baseline V3 instructions ###

#@if defined(BASELINE_V3)

### ALU Instructions (V3 16-bit) ###

imm6u_: imm8 is imm6u [ imm8 = imm6u << 2; ] { export *[const]:4 imm8; }
:addri36.sp rr19, imm6u_ is opsz=1 & opc6=0b011000 & rr19 & imm6u_ { rr19 = sp + imm6u_; }
:add5.pc rr21b is opsz=1 & opc10=0b1011101101 & rr21b { rr21b = pc + rr21b; }
:and33 rr19, ra3 is opsz=1 & opc6=0b111111 & rr19 & ra3 & imm3u=0b110 { rr19 = rr19 & ra3; }
:neg33 rr19, ra3 is opsz=1 & opc6=0b111111 & rr19 & ra3 & imm3u=0b010 { rr19 = -ra3; }
:nor193 rr19, ra3 is opsz=1 & opc6=0b111111 & rr19 & ra3 & imm3u=0b011 { rr19 = ~ra3; }
:or33  rr19, ra3 is opsz=1 & opc6=0b111111 & rr19 & ra3 & imm3u=0b111 { rr19 = rr19 | ra3; }
:xor33 rr19, ra3 is opsz=1 & opc6=0b111111 & rr19 & ra3 & imm3u=0b101 { rr19 = rr19 ^ ra3; }

### Bit Manipulation Instructions (V3 16-bit) ###

:bmski33 rr19, imm3ub is opsz=1 & opc6=0b001011 & rr19 & imm3ub & imm3u=0b110 { rr19 = (rr19 >> imm3ub) & 1; }
:fexti33 rr19, imm3ub is opsz=1 & opc6=0b001011 & rr19 & imm3ub & imm3u=0b111 { rr19 = rr19 & ((1 << (imm3ub + 1)) - 1); }

### Misc. Instructions (V3 16-bit) ###

imm7n: off is imm5u [ off = -((32 - imm5u) << 2); ] { export *[const]:4 off; }
:lwi45.fe rr20, [imm7n] is opsz=1 & opc6=0b011001 & rr20 & imm7n { addr:4 = r8 + imm7n; rr20 = *addr; }

:movd44 rr21e1, ra5e1 is opsz=1 & opc7=0b1111101 & rr21e1 & rr21e2 & ra5e1 & ra5e2 { rr21e1 = ra5e1; rr21e2 = ra5e2; }

imm5u_: imm6 is imm5u [ imm6 = imm5u + 16; ] { export *[const]:4 imm6; }
:movpi45 rr20, imm5u_ is opsz=1 & opc6=0b111101 & rr20 & imm5u_ { rr20 = imm5u_; }
r:mul33  rr19, ra3 is opsz=1 & opc6=0b111111 & rr19 & ra3 & imm3u=0b100 { rr19 = rr19 * ra3; }

# Note: POP25 and PUSH25 are highly untested ! And they just look messy :/
imm5u__: imm8 is imm5u [ imm8 = imm5u << 3; ] { export *[const]:4 imm8; }

macro push25_special() { Smwad(lp); Smwad(gp); Smwad(fp); }
macro push25_r6() { Smwad(r6); }
macro push25_r8() { Smwad(r8); Smwad(r7); push25_r6(); }
macro push25_r10() { Smwad(r10); Smwad(r9); push25_r8(); }
macro push25_r14() { Smwad(r14); Smwad(r12); Smwad(r12); Smwad(r11); push25_r10(); }

push25_re: re2 is re2 & re2=0 { push25_r6(); }
push25_re: re2 is re2 & re2=1 { push25_r8(); }
push25_re: re2 is re2 & re2=2 { push25_r10(); }
push25_re: re2 is re2 & re2=3 { push25_r14(); }

:push25 push25_re, imm5u__ is opsz=1 & opc8=0b11111000 & re2 & push25_re & imm5u__ {
	mult_addr = sp;
	push25_special();
	build push25_re;
	sp = mult_addr - imm5u__;
	if(re2 < 1) goto <end>;
		r8 = pc & 0xfffffffc;
	<end>
}

macro pop25_special() { Lmwbi(fp); Lmwbi(gp); Lmwbi(lp);   }
macro pop25_r6() { Lmwbi(r6); }
macro pop25_r8() { pop25_r6(); Lmwbi(r7); Lmwbi(r8); }
macro pop25_r10() { pop25_r8(); Lmwbi(r9); Lmwbi(r10); }
macro pop25_r14() { pop25_r10(); Lmwbi(r11); Lmwbi(r12); Lmwbi(r12); Lmwbi(r14); }

pop25_re: re2 is re2 & re2=0 { pop25_r6(); }
pop25_re: re2 is re2 & re2=1 { pop25_r8(); }
pop25_re: re2 is re2 & re2=2 { pop25_r10(); }
pop25_re: re2 is re2 & re2=3 { pop25_r14(); }

:pop25 pop25_re, imm5u__ is opsz=1 & opc8=0b11111001 & re2 & pop25_re & imm5u__ {
	mult_addr = sp;
	build pop25_re;
	pop25_special();
	sp = mult_addr + imm5u__;
	return [lp];
}


#@endif

############ Floating-point ############

#@if defined(FPU)

define register offset=0x114 size=8 [
    fd0 fd1 fd2 fd3 fd4 fd5 fd6 fd7 fd8 fd9 fd10 fd11 fd12 fd13 fd14 fd15
    fd16 fd17 fd18 fd19 fd20 fd21 fd22 fd23 fd34 fd25 fd26 fd27 fd28 fd29 fd30 fd31
];

define register offset=0x114 size=4 [
    fs0 fs1 fs2 fs3 fs4 fs5 fs6 fs7 fs8 fs9 fs10 fs11 fs12 fs13 fs14 fs15
    fs16 fs17 fs18 fs19 fs20 fs21 fs22 fs23 fs34 fs25 fs26 fs27 fs28 fs29 fs30 fs31
];

define register offset=0x200 size=4 [
    fcsr fcfg    
];

define token fpu(32)
    FOpSz       = (31, 31)
    COP         = (25, 30)
    FDt         = (20, 24)
    FSt         = (20, 24)
    FRt         = (20, 24)
    FSa         = (15, 19)
    FSb         = (10, 14)
    FRa         = (15, 19)
    FDa         = (15, 19)
    FDb         = (10, 14)
    FCSR        = (10, 14)
    FCFG        = (10, 14)

    Imm12u      = (0, 11)
    Imm12s      = (0, 11) signed

    bi          = (12, 12)

    FUI2D       = (10, 14)
    FOP         = (6, 9)
    FXR         = (6, 9)
    CP0         = (4, 5)
    MxCP        = (0, 3)
    FD1         = (0, 3)
    FS1         = (0, 3)
;

attach variables [FRt FRa] [
    r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r12 r14 r15 r16 r17 r18 r19 r20 r21 r22 r23 r24 r25 p0 p1 fp gp lp sp
];

attach variables [FDt FDa FDb] [
    fd0 fd1 fd2 fd3 fd4 fd5 fd6 fd7 fd8 fd9 fd10 fd11 fd12 fd13 fd14 fd15
    fd16 fd17 fd18 fd19 fd20 fd21 fd22 fd23 fd34 fd25 fd26 fd27 fd28 fd29 fd30 fd31
];

attach variables [FSt FSa FSb] [
    fs0 fs1 fs2 fs3 fs4 fs5 fs6 fs7 fs8 fs9 fs10 fs11 fs12 fs13 fs14 fs15
    fs16 fs17 fs18 fs19 fs20 fs21 fs22 fs23 fs34 fs25 fs26 fs27 fs28 fs29 fs30 fs31
];

### Load / Store Instruction (immediate) ###

FloatWordOffset: off is Imm12s [ off = Imm12s << 2; ] { export *[const]:4 off; }

AddrFloatWordRaImm12s: [FRa + FloatWordOffset] is FRa & FloatWordOffset { addr:4 = FRa + FloatWordOffset; export addr; }

:fsdi  FDt, AddrFloatWordRaImm12s is FOpSz=0 & COP=0b011011 & FDt & bi=0 & AddrFloatWordRaImm12s { *AddrFloatWordRaImm12s = FDt; }
:fssi  FSt, AddrFloatWordRaImm12s is FOpSz=0 & COP=0b011001 & FSt & bi=0 & AddrFloatWordRaImm12s { *AddrFloatWordRaImm12s = FSt; }
:fldi  FDt, AddrFloatWordRaImm12s is FOpSz=0 & COP=0b011010 & FDt & bi=0 & AddrFloatWordRaImm12s { FDt = *AddrFloatWordRaImm12s; }
:flsi  FSt, AddrFloatWordRaImm12s is FOpSz=0 & COP=0b011000 & FSt & bi=0 & AddrFloatWordRaImm12s { FSt = *AddrFloatWordRaImm12s; }

### Load / Store Instruction (immediate, postincr) ###

:fsdi.bi  FDt, [FRa], FloatWordOffset is FOpSz=0 & COP=0b011011 & FDt & bi=1 & FRa & FloatWordOffset { *FRa = FDt; FRa = FRa + FloatWordOffset; }
:fssi.bi  FSt, [FRa], FloatWordOffset is FOpSz=0 & COP=0b011001 & FSt & bi=1 & FRa & FloatWordOffset { *FRa = FSt; FRa = FRa + FloatWordOffset; }
:fldi.bi  FDt, [FRa], FloatWordOffset is FOpSz=0 & COP=0b011010 & FDt & bi=1 & FRa & FloatWordOffset { FDt = *FRa; FRa = FRa + FloatWordOffset; }
:flsi.bi  FSt, [FRa], FloatWordOffset is FOpSz=0 & COP=0b011000 & FSt & bi=1 & FRa & FloatWordOffset { FSt = *FRa; FRa = FRa + FloatWordOffset; }

### Move Instruction ###

:fmfcfg FRt is FOpSz=0 & COP=0b110101 & FCFG=0 & FXR=0b1100 & MxCP=0b0001 & CP0=0 & FRt { FRt = fcfg; }
:fmfcsr FRt is FOpSz=0 & COP=0b110101 & FCSR=1 & FXR=0b1100 & CP0=0 & MxCP=0b0001 { FRt = fcsr; }
:fmfsr FRt, FSa is FOpSz=0 & COP=0b110101 & FRt & FSa & FXR=0 & CP0=0 & MxCP=0b0001 { FRt = FSa; }
:fmtcsr FRt is FOpSz=0 & COP=0b110101 & FCSR=0b00001 & FXR=0b1100 & CP0=0 & MxCP=0b1001 & FRt { fcsr = FRt; } 
:fmtsr FRt, FSa is FOpSz=0 & COP=0b110101 & FXR=0 & FRt & FSa & MxCP=0b1001 { FSa = FRt; } 

### Conversion ### 

:fui2d FDt, FSa is FOpSz=0 & COP=0b110101 & FDt & FSa & FUI2D=0b01000 & FOP=0b1111 & FD1=0b1000 { FDt = int2float(FSa); }

### Arithmetic ###

:fmuld FDt, FDa, FDb is FOpSz=0 & COP=0b110101 & FDt & FDa & FDb & FOP=0b1100 & FD1=0b1000 { FDt = FDa * FDb; }
:faddd FDt, FDa, FDb is FOpSz=0 & COP=0b110101 & FDt & FDa & FDb & FOP=0 & FD1=0b1000 { FDt = FDa + FDb; }
:fdivd FDt, FDa, FDb is FOpSz=0 & COP=0b110101 & FDt & FDa & FDb & FOP=0b1101 & FD1=0b1000 { FDt = FDa / FDb; }
:fd2ui.z FSt, FDa is FOpSz=0 & COP=0b110101 & FSt & FDa & FUI2D=0b10100 & FOP=0b1111 & FD1=0b1000 { FSt = float2float(floor(FDa)); }

### Other ###

:fcpyss FSt, FSa, FSb is FOpSz=0 & COP=0b110101 & FSt & FSa & FSb & FOP=0b0011 & FS1=0b0000 
{ 
    FSt = (FSa & 0x7fffffff) | (FSb & 0x80000000); 
}

#@endif
